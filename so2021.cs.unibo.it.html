<!doctype html>
<html lang="en">
<head>
<title>so2021.cs.unibo.it</title>
<meta name="generator" content="Etherpad">
<meta name="author" content="Etherpad">
<meta name="changedby" content="Etherpad">
<meta charset="utf-8">
<style>
ol {
  counter-reset: item;
}

ol > li {
  counter-increment: item;
}

ol ol > li {
  display: block;
}

ol > li {
  display: block;
}

ol > li:before {
  content: counters(item, ".") ". ";
}

ol ol > li:before {
  content: counters(item, ".") ". ";
  margin-left: -20px;
}

</style>
</head>
<body>
<strong>Corso di Sistemi Operativi AA 2020&#x2F;2021 - Primo semestre</strong><br><br><strong>Link al pad del secondo semestre:</strong><br><ul class="bullet"><li><a href="https&#x3a;&#x2F;&#x2F;etherpad&#x2e;wikimedia&#x2e;org&#x2F;p&#x2F;OoPeXXX4XJSIPCAN2jDo" rel="noreferrer noopener">https:&#x2F;&#x2F;etherpad.wikimedia.org&#x2F;p&#x2F;OoPeXXX4XJSIPCAN2jDo</a></ul><br>&#x2F;&#x2F; PER FAVORE DATEVI UN NICK (anche di fantasia) COS&#204; SAPPIAMO CHI SCRIVE<br>&#x2F;&#x2F; USARE LA CHAT PER I MESSAGGI, NON SCRIVERE SUL DOCUMENTO<br><br><strong>Legenda:</strong><br><ul class="bullet"><li>[*] = citazioni o contenuti in pi&#249;</li><li>Testo in grassetto= da verificare, rivedere e&#x2F;o corregger</li><li>Testo Sottolineato = particolare importanza</ul>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><strong>Per vedere lo schermo del prof (read only):</strong><br><ul class="bullet"><li><a href="http&#x3a;&#x2F;&#x2F;www&#x2e;cs&#x2e;unibo&#x2e;it&#x2F;&#x7e;renzo&#x2F;live&#x2F;noVNC&#x2F;vnc&#x5f;auto&#x2e;html&#x3f;host&#x3d;novnc&#x2e;virtlab&#x2e;unibo&#x2e;it&amp;port&#x3d;8080&amp;password&#x3d;readonly" rel="noreferrer noopener">http:&#x2F;&#x2F;www.cs.unibo.it&#x2F;~renzo&#x2F;live&#x2F;noVNC&#x2F;vnc_auto.html?<u>host=novnc.virtlab.unibo.it&amp;port=8080&amp;password=readonly</u></a></ul><br><strong>Documenti interessanti:&nbsp;</strong><br><ul class="bullet"><li><a href="http&#x3a;&#x2F;&#x2F;so&#x2e;v2&#x2e;cs&#x2e;unibo&#x2e;it&#x2F;wiki&#x2F;index&#x2e;php&#x3f;title&#x3d;Il&#x5f;&#x25;27&#x25;27catalogo&#x25;27&#x25;27&#x5f;delle&#x5f;System&#x5f;Call" rel="noreferrer noopener">http:&#x2F;&#x2F;so.v2.cs.unibo.it&#x2F;wiki&#x2F;index.php?title=Il_%27%27catalogo%27%27_delle_System_Call</a></li><li><a href="http&#x3a;&#x2F;&#x2F;man&#x2e;cat&#x2d;v&#x2e;org&#x2F;unix&#x2d;6th&#x2F;2&#x2F;" rel="noreferrer noopener">http:&#x2F;&#x2F;man.cat-v.org&#x2F;unix-6th&#x2F;2&#x2F;</a>&nbsp; (elenco delle prime syscall (71&#x2F;72))</li><li><a href="http&#x3a;&#x2F;&#x2F;www&#x2e;cs&#x2e;unibo&#x2e;it&#x2F;&#x7e;renzo&#x2F;so&#x2d;lso&#x2F;lucidi&#x2F;" rel="noreferrer noopener">http:&#x2F;&#x2F;www.cs.unibo.it&#x2F;~renzo&#x2F;so-lso&#x2F;lucidi&#x2F;</a> (vecchi lucidi)</li><li><a href="http&#x3a;&#x2F;&#x2F;www&#x2e;cs&#x2e;unibo&#x2e;it&#x2F;&#x7e;renzo&#x2F;so&#x2F;lucidi2020&#x2d;21&#x2F;" rel="noreferrer noopener">http:&#x2F;&#x2F;www.cs.unibo.it&#x2F;~renzo&#x2F;so&#x2F;lucidi2020-21&#x2F;</a> (lucidi del secondo semestre)</ul><br><strong>Secondo pad:</strong><br><ul class="bullet"><li><a href="https&#x3a;&#x2F;&#x2F;hackmd&#x2e;io&#x2F;&#x40;ODccqFFKQtS2v7p0G43ysQ&#x2F;sisop" rel="noreferrer noopener">https:&#x2F;&#x2F;hackmd.io&#x2F;@ODccqFFKQtS2v7p0G43ysQ&#x2F;sisop</a></ul><br><strong>Link al pizzino:</strong>&nbsp;<br><ul class="bullet"><li><a href="https&#x3a;&#x2F;&#x2F;etherpad&#x2e;wikimedia&#x2e;org&#x2F;p&#x2F;so2021&#x2e;pizzino" rel="noreferrer noopener">https:&#x2F;&#x2F;etherpad.wikimedia.org&#x2F;p&#x2F;so2021.pizzino</a></li><li><a href="https&#x3a;&#x2F;&#x2F;etherpad&#x2e;wikimedia&#x2e;org&#x2F;p&#x2F;so2021&#x2e;pyzzino" rel="noreferrer noopener">https:&#x2F;&#x2F;etherpad.wikimedia.org&#x2F;p&#x2F;so2021.pyzzino</a></ul><br># ZONA CRAVATTE --------------------------------------------------------------------------------------------------------------<br>30&#x2F;09&#x2F;20 Cravatta biglietto da visita (VirtualSquare)&nbsp;<br>02&#x2F;10&#x2F;20 Cravatta con pinguini linux (tux)<br>07&#x2F;10&#x2F;20 Cravatta con la stele di Rosetta&nbsp;<br>09&#x2F;10&#x2F;20 Cravatta met&#224; a scacchi blu e met&#224; fantasia floreale lo incuriosiva e l&#x27;ha comprata (dovrebbe simboleggiare la struttura di un sistema operativo)<br>14&#x2F;10&#x2F;20 Cravatta con formula di eulero<br>16&#x2F;10&#x2F;20 Cravatta impressionista con le ninfee di Monet<br>21&#x2F;10&#x2F;20 Cravatta con linee parallele (in riferimento alla programmazione concorrente)<br>23&#x2F;10&#x2F;20 Cravatta verde con topolino: idea dell&#x27;interfaccia delle system call<br>28&#x2F;10&#x2F;20 Cravatta Tassellazione dello spazio di Escher<br>30&#x2F;10&#x2F;20 Cravatta Silvestrino e Speedy Gonzales<br>04&#x2F;11&#x2F;20 Cravatta con le prospettive impossibili di Escher (tutto si pu&#242; vedere da pi&#249; punti di vista)<br>06&#x2F;11&#x2F;20 Cravatta con pinguini, &#232; divertente interagire con pinguini di varia natura<br>11&#x2F;11&#x2F;20 Cravatta con simboli di accensione<br>13&#x2F;11&#x2F;20 Cravatta con una pellicola di Paperino (perch&#232; gli eventi sono come i fotogrammi di una pellicola)<br>18&#x2F;11&#x2F;20 Cravatta che rappresenta le mattonelle del passeig de gracia (singoli processi combinati per avere un effetto complessivo)<br>20&#x2F;11&#x2F;20 Cravatta RIP CRAVATTA 20&#x2F;11&#x2F;20 HA scioperato ed &#232; tinta unita (tipo marrone)<br>25&#x2F;11&#x2F;20 Cravatta con frattale (c &#232; tanto parallelismo e ha delle forme inaspettate)<br>27&#x2F;11&#x2F;20 Cravatta con Topolino in tre fasi: pensa, pensa pi&#249; forte, &#232; felice &#8594; logica del progetto<br>02&#x2F;12&#x2F;20 Cravatta comprata in Florida quando and&#242; a vedere Cape Canaveral &#8594; chi conosce i SO pu&#242; lavorare per ESA, NASA ecc<br>04&#x2F;12&#x2F;20 Cravatta color oro con texture tipo marmo fatta di sughero non di seta (guardare oltre)<br>09&#x2F;12&#x2F;20<br>11&#x2F;12&#x2F;20<br>23&#x2F;02&#x2F;21<br>26&#x2F;02&#x2F;21<br><br># LEZIONE DEL 07&#x2F;10&#x2F;2020 ----------------------------------------------------------------------------------------------------<br>Pattern da evidenziare in:&nbsp;<br><a href="http&#x3a;&#x2F;&#x2F;so&#x2e;v2&#x2e;cs&#x2e;unibo&#x2e;it&#x2F;wiki&#x2F;index&#x2e;php&#x3f;title&#x3d;Esercizi&#x5f;di&#x5f;&#x25;22lettura&#x25;22&#x5f;programmi&#x5f;in&#x5f;C&#x5f;2020&#x2F;21" rel="noreferrer noopener">http:&#x2F;&#x2F;so.v2.cs.unibo.it&#x2F;wiki&#x2F;index.php?title=Esercizi_di_%22lettura%22_programmi_in_C_2020&#x2F;21</a><br>Esercizi di lettura in C (Commentiamo il codice presente all&#x27;indirizzo qui sopra).<br><br>Funzioni senza uso di librerie<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1. quine:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * il programma che scrive il suo codice sorgente come output<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1. enums:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Serve per dare nomi a degli interi.&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Serve solo per documentazione.&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1. arrays, pointers, and structs (guardare esempio):&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Le strutture sono le modalita che ha il c per creare tipi di dato complessi che hanno pi&#249; campi.&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ad esempio In questo caso (vedere documentazione) la struttura ha un stringa con &quot;hello&quot; all&#x27;interno.&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Ci sono molte differenze fra queste 3 strutture.(strutture, array, puntatori)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Un puntatore &#232; una variabile che contiene un indirizzo (duh..) a questa scatola (*spoint nell&#x27;esempio) e&#x27; associato l&#x27;indirizzo del primo carattere di &quot;hello&quot;. Spoint pu&#242; variare, possiam farlo puntare ad altro.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * gli array (sarr) sono una costante di tipo puntatore, sarr nomina l&#x27;array ma l&#x27;array e&#x27; una costante (davoli essere tipo &quot;variabile costante&quot;), quindi sarr non lo possiamo far puntare a qualcos&#x27;altro.&nbsp; cambiare il terzo valore di spoint &#232; vietato, mentre in sarr &#232; permesso. Una costante di tipo puntatore la posso assegnare a una variabile di tipo puntatore ma non vale il viceversa in quanto la costante non pu&#242; essere riassegnata.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; Al puntatore non &#232; possibile accedere in scrittura ma solo in lettura<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * La struttura si pu&#242; passare per valore e quando viene passata per valore viene copiata.&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * ricordiamo che le strutture si passano per valore<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * (metanota: ragazzi vi assicuro che eseguire il codice e dare un occhio &#232; molto piu utile).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1. alignments<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * le due strutture hanno dimensioni diverse nonostante contengano gli stessi tipi<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Ci&#242; &#232; dovuto all&#x27;alignment poich&#232; il long va sempre messo a un indirizzo multiplo di 8&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1. iteration and recursion&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * skippato<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1. comma operator<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * operatore virgola: (facciamo riferimento al for), quelle due espressione fanno parte del primo parametro (i=0, j=slen(s)-1), in questo modo incremento uno e decremento (tipo divide et impera) l&#x27;altro, posso fare piu operazioni in una singola riga.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * reverse usa la stessa tecnica per fare il reverse di una stringa (e usa circonflesso uguale&nbsp; = xor?)&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * a = 1, 2, 3;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a prende il primo valore. &#232; come se fosse (a=1),2,3;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * b = (1, 2, 3);&nbsp;&nbsp;&nbsp;&nbsp; b prende il terzo valore perch&#233; viene modificata la precedenza con le parentesi<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * &#232; l&#x27;operatore che ha meno precedenza (anche meno dell&#x27;uguale)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * ^= associativo a destra (forse vale per tutti gli operatori?)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1. string by value&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2. preprocessor quine<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3. tables and preprocessor trick<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4. arrays and pointers<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5. void * and function pointers<br><br>Funzioni con uso di librerie<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1. char by char copy (stdio)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2. similar programs, different approaches (stdio, string, stdlib, ctype)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3. first program<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4. second program<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5. Command line args management (getopt)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6. dynamic allocation on the heap, qsort, getline (stdlib)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7. open_memstream (quite tricky)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8. fantasy of strcpy (time, stdint, string)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9. math and printf<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10. minishell (history and execs)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11. conversions (math)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12. A home-brewed mini-printf (variadic functions, indirect recursion)<br><br>Quali sono gli elementi che permettono di implementare un sistema operativo.<br><br>Che cosa fa parte della libreria e cosa fa parte del l inguaggio ?&nbsp;<br><br>Il SO &#232; quel programma avviato all&#x27;accensione della macchina e che rimane attivo fino alla fine. Quando &#232; presente un errore che non permette di eseguire il codice il SO si interrompe (Kernel panic&#x2F;BSoD).&nbsp;<br><br>Include &#232; un comando in grado di avviare, comprendere ed eseguire un programma &#232; introduce&nbsp;<br>Senza Include gli si stanno passando istruzioni che non riesce a comprendere senza importare definizioni.<br>Al precompilatore, l&#x27;istruzione di include viene eseguita inserendo il contenuto del file di libreria all&#x27;interno dei file da precompilare.<br>Le direttive per il preprocessore non influenzano&nbsp; numero di riga degli errori segnalati dal compilatore (&quot;ricomincia a contare da 1&quot;)<br><br>Se il compiltore non conosce il tipo di una funzione lo considera Int<br>&quot;!$&quot; inserisce il parametro dell&#x27;ultimo comando eseguito (shell)<br>il compilatore riconosce i file dal suffisso.<br><br>Il compilatore f&#224; solo una fase iniziale delle fasi: compila, dammi l&#x27;oggetto. e per fare quello ci sono delle opzioni -o, -s, ....<br><br>Gcc options:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; gcc &#8211;E: preprocessore<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; gcc &#8211;S: assembler<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; gcc &#8211;c: codice oggetto<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; $$: pid della shell<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; $?: ultimo valore ritornato alla shell<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; gcc -O2: ottimizzatore<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; gcc -static: linkaggio statico<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; nm: elenco dei simboli presenti nell&#8217;eseguibile (Symbol Table)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; ld: linkaggio<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; as: compila l&#8217;assembly in un .o<br><br>Gli si pu&#242; specificare di fare una sola parte della catena di un programma che viene da un altro linguaggio.<br><br>Il programma &#232; un testo.<br>L&#x27;attivit&#224; derivante dall&#x27;esecuzione del programma &#232; il processo<br><br>da C99 (ISO&#x2F;IEC 9899:1999) non sono pi&#249; ammesse le implicit declaration<br>l<br>trivia: [Ubuntu = io sono quello che sono per merito di quelli che sono intorno a me(il simbolo di ubuntu sono tre persone che si abbracciano)&#10084;]&nbsp;<br><br>Tentativo di scrivere codice senza la libreria C: quindi senza printf, opzioni input&#x2F;output<br>Il valore di ritorno del main sembra non essere una funzione della libreria. Non viene stampata ma &#232; comunque esistita. Si possono fare cicli e inizializzare variabili senza la libreria.&nbsp;<br><br>L&#x27;ottimizzatore non ha il controllo della variabile se si usa volatile . Si possono cambiare senza passare dallo stesso programma. Non era<br><br>Due tipi di funzioni: di libreria e per il System call.<br><br>Un processo non termina mai da solo, serve la system call exit cio&#232; si &quot;suicida&quot;<br>Oppure in alcuni casi il processo viene &quot;ucciso&quot; se si verificano determinate condizioni (es. Codice 9)<br><br>Lo _start inizializza lo stack ed esegue la chiamata del &quot;main&quot;&nbsp;<br>Il main ha 3 parametri argc, argv ed envp che &#232; spesso omesso. (argc, argv sono standard C, envp &#232; specifico Linux)<br><br>call main -&gt; chiamata di subroutine<br><br>Una volta caricati i parametri si chiama il main, all&#x27;uscita&nbsp; il programma chiama la syscall per terminare programma.&nbsp;<br><br>[Da gnu.org:&nbsp;<br>#&nbsp; A system call is a request for service that a program makes of the kernel.&nbsp; The service is generally something that only the kernel has the privilege to do, such as doing I&#x2F;O.&nbsp; Programmers don&#8217;t normally need to be concerned with system calls because there are functions in the GNU C Library to do virtually everything that system calls do. These functions work by making system calls themselves.&nbsp; For example, there is a system call that changes the permissions of a file, but you don&#8217;t need to know about it because you can just use the GNU C Library&#8217;s chmod function.]<br>spiegazione di davoli: l&#x27;unica operazione che pu&#242; fare un processo per attirare l&#x27;attenzione del kernel (operazioni in corsivo dell&#x27;es dell&#x27;altra volta)<br><br>[write(int fd, const void *buf, size_t nbytes ) parameters:<br>fd It is the file descriptor which has been obtained from the call to open. It is an integer value. The values 0, 1, 2 can also be given, for standard input, standard output &amp; standard error, respectively .&nbsp;<br>buf It points to a character array, with content to be written to the file pointed to by fd.&nbsp;<br>nbytes It specifies the number of bytes to be written from the character array into the file pointed to by fd. ]<br><br>ssize_t al posto di long unsigned poich&#232; di architettura in architettura la dimensione dei long&#x2F;short&#x2F;etc pu&#242; variare mentre ssize_t no, rimane sempre costante dappertutto (diciamo meglio size_t &#232; sempre quello che l&#x27;API si aspetta come tipo, potrebbe cambiare nel tempo o in machine diverse, ma usando size_t siamo certi che sia sempre il tipo coerente)<br>trick: typdef long ssize_t<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typdef unsigned long size_t<br><br>register keyword: serve per dire di mettere la variabile in un registro, magari ottimizzando il programma<br><br>Funzioni come strlen si possono implementare &quot;in modo normale&quot; senza usare systemcall, funzioni come printf devono usare systemcall per funzionare(??)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>Da &quot;man cat&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cat - concatenate files and print on the standard output (tutti lo usano per stampare un file singolo)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>--------------------------<br>volatile - ottimizzatore non ha il controllo della variabile se si usa volatile<br>DDRC - il prof lo usa come modo per definire (*(volatile uint8_t *) 0x27) ma cosa vogliono dire tutti sti asterischi? sono puntatori a puntatori direi (potete confermare?)<br>NO. 0x27 &#232; un numero (39 per gli umani), (volatile uint8_t *) 0x27 dice al compilatore di considerare il numero come puntatore a uint8_t (un byte) e l&#x27;asterisco iniziale dice &quot;il puntato da&quot;. Letto tutto insieme e&#x27;: ci&#242; che &#232; puntato da 0x27 visto come puntatore a uint8_t, quindi DDRC &#232; in breve il contenuto dell&#x27;indirizzo 39.<br>DDRC = 42 scriverebbe 42 all&#x27;indirizzo 39<br>x = DDRC assegna ad x il valore presente all&#x27;indirizzo 39. Attenzione: l&#x27;indirizzo 39 corrisponde a un porta di I&#x2F;O non &#232; un indirizzo di memoria.<br>DDRC |= 1 &lt;&lt;5 - prende il 6&#176; bit di DDRC e lo mette a 1 in caso sia 0<br><br>1 Shift (ovvero &#x27;&lt;&lt;&#x27;) 5 = 100000 (Binario)<br>(<a href="https&#x3a;&#x2F;&#x2F;www&#x2e;tutorialspoint&#x2e;com&#x2F;cprogramming&#x2F;c&#x5f;assignment&#x5f;operators&#x2e;htm&#x29;" rel="noreferrer noopener">https:&#x2F;&#x2F;www.tutorialspoint.com&#x2F;cprogramming&#x2F;c_assignment_operators.htm)</a><br><br>^= xor (exclusive or) uguale =&gt; se &#232; 0 diventa 1 e viceversa (restituisce 1 solo quando i bit confrontati sono diversi), come dire C = C ^ 1<br>0^0=0<br>0^1=1<br>1^0=1<br>1^1=0<br>nota: XOR bit^0=bit<br><br>il for invece inverte il sesto bit di PORTC 32767 volte tramite una xor<br>&#x2F;&#x2F;ma la motivazione di questo codice? me la son persa *scrivere qui pls<br>Il for interno fa 32767 cicli senza far nulla (per aspettare un tempo &quot;umano&quot;, circa 1 sec), poi cambia il valore del bit in PORTC. Queste due operazioni (for interno e flip del bit di PORTC) vengono fatte per sempre, PORTC non &#232; una variabile ma &#232; l&#x27;indirizzo di un banco di 8 porte, il bit che cambiamo e&#x27; la porta alla quale &#232; collegato il led che lampeggia.<br><br>La morale &#232; con il C si pu&#242; lavorare a tutti i livelli direttamente a contatto con l&#x27;hardware o sopra soffici &quot;materassi&quot;&#x2F;strati di software.<br><br># LEZIONE DEL 09&#x2F;10&#x2F;2020 ----------------------------------------------------------------------------------------------------<br><br>Quando il programmatore che lavora in c, pensa in assembler o macchina, dice &quot;caro amico compilatore ci sar&#224; una variabile che si chiama syscallno. Mettila in un registro se possibile e si pu&#242; anche indicare in quale (nell&#x27;esempio &quot;rax&quot;)&quot;. Questo viene fatto dal programmatore perch&#233; sa che user&#224; la variabile molto spesso e la vuole tenere vicina&#x2F;comoda.&nbsp;<br>Ho dato due nomi alla variabile, perch&#232; (linux) si.....<br><br>Bisogna pensare alla leggibilit&#224; quando si scrive codice. Dobbiamo pensare a noi stessi e di come possiamo riconoscere il testo anche a distanza di anni.&nbsp;<br>La syscall &#232; il cuoco che cambia d&#x27;abito e segue il codice del kernel(da cuoco bianco a cuoco K). In rx c&#x27;&#232; il codice di ritorno perch&#232; il cuoco prima di tornare vestito di bianco l&#x27;ha lasciato l&#236;. L&#x27;effetto della syscall che permette di far ritornare il valore.&nbsp;<br><br>REGISTRI<br>RX numero Sc<br>R2 parametri&nbsp;<br>rdi<br>rsi<br>rdx<br>r10<br>r8<br>r9<br><br>Select ha 5&#x2F;6 se uno lo vuole chiamare a mano questi 6 parametri lunghi una voce li deve mettere nei registri.&nbsp;<br>La pselect &#232; una funzione implementata dentro la libreria c ma non &#232; altro che quello che abbiamo fatto noi a mano, mettere le variabili nei registri e chiamare la syscall.<br><br>Un programma &#232; un testo. Quindi non ha un risultato se non il risultato del processo, l&#x27;effetto.<br>L&#x27;attivit&#224; risultante dall&#x27;esecuzione del programma. Il linguaggio &#232; un accordo che c&#x27;&#232; fra entit&#224; che devono comunicare. Formalmente in info un linguaggio &#232; un oggetto composto da 4 item. Funzione quadrupla ( alfabeto, lessico, sintassi, semantica). Un&#x27;alfabeto &#232; un insieme di simboli. Quindi l&#x27;alfabeto che usiamo &#232; quello latino ma non &#232; strettamente collegato alle lingue scritte. Ad esempio i fonemi che produce il prof per spiegare la lezione.&nbsp; Sono entit&#224; che trasmettono info, che non sono singole o svolgono da soli il loro lavoro. Ci sono parole che possono appartenere al linguaggio e altre no. Esistono sequenze permesse e sequenze non possibili.&nbsp;<br>La semantica indica il significato delle frasi corrette che vado dicendo. Un compilatore mantiene la semantica ma cambia il linguaggio del programma.&nbsp;<br>La sintassi &#232; la discriminazione tra parole corrette e non del linguaggio<br>Noi vediamo il mondo a strati! Quello che facciamo &#232; comprendere il livello pi&#249; alto del linguaggio, la semantica<br>Aggiungiamo strati per elevare il linguaggio da macchina ad un tipo pi&#249; alto (ignorando&nbsp; ci&#242; che c&#x27;&#233; sotto).<br>Si pu&#242; pensare all&#x27;hardware come ad un linguaggio.&nbsp;<br><br>compilatore: traduce da un linguaggio ad un altro mantenendo la semantica<br>linguaggio: accordo tra entit&#224; che devono comunicare e composto da:<br>-alfabeto: insieme di simboli<br>-lessico:<br>-sintassi: &#232; la discriminazione tra parole corrette e non del linguaggio<br>-semantica: indica il significato delle parole corrette<br>il gradino pi&#249; basso di interazione che abbiamo con il sistema &#232; il linguaggio macchina<br><br>transpiler: compilatore da linguaggio macchina a linguaggio macchina (source-to-source compiler)<br><br>[Massima di Einstein:&quot;La scienza pi&#249; che essere un frutto dell&#x27;inspirazione &#232; un frutto della traspirazione(?)&quot;&#10084;]<br><br>Il livello processore + perifeche sta al livello sottostante del SO. Tutta la parte relativa all&#x27;accesso diretto ai dispositivi &#232; nascosta e vietata per evitare danni.&nbsp; Non esisterebbe<br>&nbsp;protezione per l&#x27;accesso ai file da parte dell&#x27;utente.<br><br>Le librerie possono usare il processore e poi dialogare con il kernel chiedendo (servizi) delle syscall.&nbsp;<br>Ma cos&#x27;&#232; un sistema operativo? Non ci interessa tanto come fa quella cosa. Il perch&#232; ed il cosa sono pi&#249; solidi.&nbsp;<br>A cosa serve un sistema operativo. Serve per creare un livello di astrazione. Se programmassi a livello del linguaggio dell&#x27;hw sarei molto limitato a trasferire il programma su altri dispositivi. Se anche cambia il modello vogliamo la garanzia che funzioni mediante la nostra astrazione. In questo modo mascheriamo le particolarit&#224; degli hardware.<br><br>Creiamo un&#x27;astrazione per mascherare le particolarit&#224; dell&#x27;hw. In questa maniera i programmi non&nbsp; si devono preoccupare di ci&#242; che sta sotto o di come usarlo: loro vedono un&#x27;interfaccia, un programma,...<br><br>L&#x27;astrazione dei processi &#232; la pi&#249; importante nei sistemi operativi (creata da esso).<br>Astrazione del multitasking: da l&#x27;impressione di stare eseguendo pi&#249; processi contemporaneamente anche se non &#232; vero. I processi che vediamo sono attivi ed esistono alternandosi e non proseguono all&#x27;unisono.<br><br>Perch&#232; usare il multitasking? perch&#232; quando deve eseguire azioni che hanno tempi di esecuzioni molto diversi, invece di star fermo ad aspettare che uno finisca, lui continua comunque gli altri processi andando ad ottimizzare i tempi. Ad esempio&nbsp; se bisogna leggere un dato sul disco (che ci mette molto tempo) invece di star fermo ad aspettare, vengono continuati altri processi. (un accesso al disco richiede O(un milione) volte il tempo necessario per eseguire una istruzione.<br><br>Abbiamo due obiettivi: vogliamo creare l&#x27;astrazione di processo e dare un interfaccia unificante per avere servizi dal sistema&nbsp;<br><br>Chi utilizza il SO? Non sono gli umani, sono i processi (che vengono usati dagli umani). In questo modo il sistema operativo pu&#242; fare un controllo delle risorse del sistema e si ha un maggiore controllo da parte del kernel che pu&#242; non permettere alcuni accessi. Questo consente un livello di affidabilit&#224; del sistema maggiore.<br><br>Dato che ci sono queste risorse (frusta, ingredienti, terrina, etc...) come le distribuisco al meglio? Quest&#x27;aspetto &#232; gestito dal SO. Molti aspetti correlati utili sono per esempio fare il contabile. Quanto tempo ci hai messo? Quante risorse hai usato? Informazioni che permetto al programmatore di migliorare il proprio codice.<br><br>Esperimento:&nbsp;<br>Installiamo un sistema operativo:&nbsp;<br>- download di due &quot;cd&quot; (oggi si usano le immagini iso (international standard organisation) scaricate su chiavetta)<br>Iso9660 &#232; un formato di file system. Ci sono tanti altri modi di rappresentarli. Questo &#232; il formato deciso per il cd rom. Studiato ad arte per contenuti che si scrivono una volta sola e poi non devono essere cambiati.&nbsp;<br>- finnix &#232; una distribuzione Linux&nbsp; live: che non si installa nella propria macchina. Molto comodo per fare recovery dei sistemi perduti.&nbsp;<br>- L&#x27;altro &#232; DebianStable scaricato nella versione netInstall, preso dal website Debian.org. La versione scelta &#232; quella con la versione pi&#249; piccola. Consente di creare sistemi basati sulla necessit&#224;.&nbsp;<br><br>Se noi creiamo un programma che consente di dialogare con il processore. Quindi fare finta di essere il capo cuoco k, agli occhi del nostro livello superiore si vede come si dispone di un cd rom. Noi non ci accorgiamo di ci&#242; che sta sotto ed &#232; pi&#249; comodo.&nbsp;<br><br>noi usiamo la macchina virtuale KVM&nbsp; (Kernel-based Virtual Machine ) derivata da un&#x27;altra macchina molto famosa chiamata QEMU<br><br>kvm -cdrom finnix-121.iso -m 1G -monitor stdio -vga vmware: avvia la kvm e fai finta di avere quel disco li, prendi un giga di memoria (-m 1G), crea una console della macchina virtuale su tastiera (monitor stdio ), prendo la scheda video di vmware (-vga vmware) per avere la risoluzione 800x600 (non supporta risoluzioni superiori), serve solo per non avere una finestra troppo grande nella GUI usata a lezione). il boot esegue il codice del firmware della scheda madre che cariva il bootloader (GRUB), poi carica il kernel (cio&#233; Linux), il kernel chiama il primo processo che poi crea tutti gli altri. Ora abbiamo il sistema funzionante live (linux).<br><br>Il kernel parte e dal primo processo parte e carica tutti gli altri. Abbiamo il sistema funzionante live.<br>Il sistema caricato &#232; linux. Lui finge di avere un disco non lavora sul cd rom.&nbsp;<br>allora, spegnamo questa macchina e vediamo di far partire... ecco...<br><br>per installare debian devo farlo partire su un disco virtuale, e come creo un disco? e&#x27; un file vuoto<br><br>sendkey [keycode] -- preme il pulsante scritto nella macchina virtuale<br><br>truncate -s 10G disk per creare un file vuoto da 10GB, in realta&#x27; in UNIX non alloca tutto questo spazio, crea un buco grande 10G, poi man mano alloca parti di disco...<br>al posto del cd rom mettiamo l&#x27;installazione debian, gli dico che uso una tastiera US<br>settiamo la lingua (inglese su consiglio del dio davoli<br>locale e&#x27; lo standard locale di formattazione (es. date)<br><br>UTF8 serve per codificare i caratteri non ASCII (Nota: si dice &#x27;aski&#x27;)<br>la figura dell&#x27;utente e dell&#x27;amministratore sono figure diverse nei sistemi seri, certi sistemi fanno si che l&#x27;utente sia quasi sempre amministratore, andando ad aumentare il rischio di virus.<br><br>il disco lo partiziona in sottoparti distinte (vedremo in futuro) (o blocchi logici)<br>una, non pu&#242; mancare, e&#x27; la partizione root, dove sta la radice il file system, l&#x27;altra e&#x27; quella di swap, area che viene usate per la memoria virtuale<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ci sono vari tipi di file system: ext4 e&#x27;&nbsp; uno dei piu avanzati oggi disponibili fra quelli progettati per Linux.<br><br>il cattivo di debian non mette come default free (non so di cosa) perch&#232; &#232; software libero<br>Debian nella sua installazione standard non inserisce i repository &quot;non-free&quot;, (vedi contenuto del file &#x2F;etc&#x2F;apt&#x2F;sources.list). Debian &#232; software libero gestito da una comunit&#224; di sviluppatori. Vuole che gli utenti diano un &quot;consenso informato&quot; quando vogliono usare codice non libero. Come effetto collaterale Debian pu&#242; aver necessit&#224; di abilitare i repo non-free (o di installare a mano pacchetti) per le funzionali&#224; avanzate spesso proprietarie di schede video o per il firware necessario ad alcune schede wifi-bluetooth.<br><br>Molti script di sistema oggi sono scritti il python e quindi il support di python viene messo anche nell&#x27;isntallazione minimale di Debian-stable versione netinst.<br><br>anche se ci cono tutti i dati neccessari sul disco &#232; necessario installare il bootloader prima di fare il reboot della macchina (solitamente GRUB di default)<br>al riavvio abbiamo terminato e vediamo la schermata di login<br><br>Gli unix, in particolare Linux, hanno una gerarchia tipica. A livello della radice bin ha le funzioni per attivare il sistema, boot anche, dev ha dei file per dare noi hai device per comunicare direttamente, etc&nbsp;<br><br>Ambiente linux e Command line:<br>nella radice troviamo le seguenti directory:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * bin - eseguibili<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * boot - necessario per far partire il sistema<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * dev - utilizzo device<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * etc - conf sistema<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * home - cartelle home per ogni utente ( Documenti, Download ecc )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * lib32 e 64 - librerie utilizzo processore<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * lost+found - quando il programma di controllo di coerenza dei file system (fsck)ha perso traccia della posizione di un file, lo mette negli oggetti smarriti<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * tmp - file temp<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * vmlinuz - &#232; il kernel<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * usr: eseguibili e librerie non strettamente necessari per far partire la macchina<br><br>Comandi:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * dmsg ti permette di vedere il resoconto delle varie operazioni di linux (copia dei messagi comparsi sulla console)<br><br>Quando accendiamo il pc, ci sono dei numerelli di tempo, che indicano i messaggi del kernel durante l&#x27;attivazione, in cui essenzialmente prova a vedere quali sono le risorse del sistema. Quando parte init, iniziano i processi per tutti i servizi. (le scritte dei processi di servizio attivati dal processo init (oggi molto spesso systemd) sono contrassegnate da [OK]<br><br>Il kernel quando parte &#232; come il cuoco che controlla i vari aspetti delle risorse del sistema. Se abbiamo aggiornato il kernel e questo non parte bene, non potremmo scegliere bene i processi che si usano.&nbsp;<br><br>Dal bootloader (GRUB) possiamo scegliere fra piu versioni o modalit&#224; del kernel.<br><br>differenza fra complitatore e interprete:&nbsp;<br>&nbsp;&nbsp;&nbsp; - l&#x27;interprete esegue diretttamente traducendo dal sorgente;<br>&nbsp;&nbsp;&nbsp; - il compilatore produce un programma tradotto che ha la stessa semantica.&nbsp;<br><br># LEZIONE DEL 14&#x2F;10&#x2F;2020 ----------------------------------------------------------------------------------------------------<br><br>Cominciamo con la command line (shell = conchiglia, si chiama cosi&#x27; perche&#x27; la conchiglia puo&#x27; nascondere all&#x27;interno una perla, ed e&#x27; lo strato piu&#x27; esterno)<br>Quello con cui stiamo dialogando &#232; un processo di nome shell. La shell si aspetta dei comandi<br>Funziona al contrario del latino: il verbo deve essere la prima parola, poi nomi poi i complementi.<br><br>Bash (acronimo per bourne again shell) &#232; una shell del progetto GNU usata nei sistemi operativi Unix e specialmente in GNU&#x2F;Linux. Si tratta di un interprete di comandi che permette all&#x27;utente di comunicare col sistema operativo attraverso una serie di funzioni predefinite o di eseguire programmi.&nbsp;&nbsp; -wikiped<br><br>In unix esiste la concezione di utente e di gruppo, ogni file appartiene ad una coppia di essi.<br><br>Le informazioni su un file sono strutturate come:<br>[permessi] [Numero di hard links al file] [utente proprietario] [gruppo di utenti proprietari][dimensione] [data ultima modifica] [nome]<br><br>i permessi annessi a utenti o gruppi possono essere<br>r: read<br>w: write<br>x: execute ( puoi entrare in una dir solo se ha questo permesso )<br><br>Quando esaminiamo i permessi, possiamo considerare le prime 3 triplette di caratteri:<br>prima tripletta: cosa pu&#242; fare proprietario<br>seconda tripletta: cosa possono fare i membri del gruppo<br>ultima tripletta: cosa pu&#242; fare il resto degli utenti<br><br>Tipi di file (prima lettera):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Link simbolico l: un file che punta a un altro file (un alias), per cambiare nome a un comando o file (anche molto altro)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Tipo d: directory (le cartelle sono un file che possono contenere file)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Tipo b: blocco<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Tipo c: carattere speciale<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - file speciali: usati per accedere a un device l attraverso dei finti file che sono nel file system stanno nella directory &#x2F;dev<br><br>Con Tab vediamo la prima&nbsp; proposta per il completamento del comando.<br>Con doppio tab vediamo tutte le proposte possibili<br><br>&quot;Sudo&quot; per avviare un comando co me amministratore (necessario l&#x27;inserimento della password)<br><br>comando ls [DIRECTORY]&nbsp; = lista di ci&#242; che contienete la Directory<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Se non viene passata nessuna dir, usa quell in cui sei attualmente<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Flag&#x2F;Option:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -l : long listing format ( Stampa permessi, owner e data di creazione dei file in una DIR)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ls &#x2F; : lista la directory ro<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ls &#x2F;bin = lista programmi in &#x2F;bin (dove si cercano programmi quando il comando non contiene il path assoluto (percorso dove trovare &quot;l&#x27;eseguibile&quot;))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ls -a = mostra tutti i file, anche quelli nascosti<br>comando echo [STRING] = stampa STRING passata, pu&#242; anche essere una variabile come $PATH<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * echo $PATH&nbsp; =&nbsp; in teoria cosi&#x27; scrive il valore di PATH con le variabili di sistema dell&#x27;env&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * con $ si riferisce ad una variabile<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * echo $? : stampa l&#x27;ultimo valore ritornato in output<br>Non fate rm -rf &#x2F;&nbsp;<br>comando sleep N = il comando viene eseguito dopo N secondi<br>comando man = manuale di un comando (passato come parametro) il manuale di un comando PU&#242; avere pi&#249; capitoli, ognuno contenente informazioni diverse:<br>&nbsp;&nbsp;&nbsp; man [capitolo] [comando]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * man 1: user commands and tools<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * man 2: system call<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * man 3: funzioni di libreria<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * man 4: file speciali<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * man 5: formati dei file speciali<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * man 6: giochi<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * man 7: argomenti di natura generale&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * man 8: comandi di system admin<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * man man = spiega la funzione del manuale.&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * man -k capability: cerca i comandi tramite parole chiave<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * man ls&nbsp; = ls del manuale<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * man fork = mostra il manuale del comando fork contenuto nel capitolo 2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * man 3 printf = mostra il manuale del comando printf contenuto nel capitolo 3<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * write si trova sia nel capitolo 1 che nel capitolo 2, con due accezioni differenti<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * man [numero] intro = per vedere a cosa corrisponde ciascun capitolo<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * man tee: capitolo del tee (duh...)<br>comando whoami = stampa nome utente&nbsp;<br>comando cat = concatena files e stampa in output<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Usato in combinazione con &#x2F;etc&#x2F; restituisce file di configurazione<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * ad esempio hostname restituisce il nome della macchina<br>comando fortune = massima del giorno<br>comando stat = essenzialmente ls -l con piu&#x27; dettagli<br>comando diff: ritorna le differenze fra 2 file in input<br>comando grep: seleziona solo le linee contenenti la stringa in input<br>comando sed: StringEDitor, se gli dai come ordine s&#x2F;&quot;..&quot; lui cerca la stringa in input e la sostituisce con il secondo argomento che passiamo. (s&#x2F;cerca&#x2F;sostituisci)<br>comando tee: scrive in un file e contemporaneamente stampa in stdout, duplicando il suo input<br>comando cp: comando per copiare&nbsp; due sintassi<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * cp file 1 file 2&nbsp;&nbsp; copia il file 1 nel 2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * cp file 1....n directory copia tutti i file nella directory<br>comando stat: usabile su un file<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * access data ultimo accesso<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * change ultima volta che gli attributi o il contenuto sono stati modificati<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * modify ultima volta che il contenuto &#232; stato modificato<br>comando rm [file]: rimuovi il file<br>comando nc: scannerizza l&#x27;intero file system&nbsp;<br>comando kill: manda un segnale a un processo per &quot;ucciderlo&quot;, non serve per i file<br>comando more:&nbsp; il comando &#232; usato per visualizzare file di testo nel terminale schermo per schermo in caso di file di grandi dimensioni ( consente solo di andare avanti nella shell )<br>comando less: come more ma consente anche di andare indietro&nbsp;<br>comando mv [file1] [file2]: cambia i nomi (e quindi sposta anche la directory)&nbsp;&nbsp;<br>comando ln: &#232; un comando che crea collegamenti simbolici e collegamenti fisici a file e directory. Se non diversamente specificato, crea collegamenti fisici.<br>Una volta che pi&#249; file sono linkati, per eliminare il file originale bisogna eliminarli tutti, inoltre non c&#x27;&#232; un modo per eliminarli tutti insieme, ma va fatto singolarmente.<br>ln -s 1 3:&nbsp; esempio di link simbolico (creazione di un alias)<br>comando touch [nomefile]: crea un file in quella directory<br>comando stat [nomefile]: da informazioni sul file<br>comando chmod: cambia i permessi del file, specifici se darli con + e -<br>comando pwd: stampa la current directory<br>comando type [nome comando]: stampa il tipo del comando (es. type cd -&gt; &quot;cd is a shell builtin&quot; comando interno alla shell)<br>comando mkdir [nome]: crea una directory chiamata nome<br><br>Device speciali:<br>&nbsp;&nbsp;&nbsp; - &#x2F;dev&#x2F;null: device che scrive null, pu&#242; essere usato cestinare dell&#x27;output in modo da non stamparlo da nessuna parte<br>&nbsp;&nbsp;&nbsp; - &#x2F;dev&#x2F;urandom: byte a caso<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uso buono: usare per sovrascrivere dati sensibili<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>System call: interfaccia per chiedere un servizio al kernel<br>vda1 = prima partizione del disco vda<br>combinazione [ctrl + D] = chiude la shell mandando un EOF marker<br><br>abbinato alla barra abbiamo bin, etc, home, boot,&nbsp;<br>etc - file di configurazione<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; se condividessimo le etc, le varie macchine si &quot;confonderebbero&quot; perch&#232; in &#x2F;etc ci sono le informazioni di configurazione della macchina<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in caso di condivisione ci sarebbe confusione su dove esattamente reperire tali informazioni di configurazione<br>bin - comandi (quelli visti fino ad ora)<br>lib - librerie&nbsp; (dentro &#x2F;lib&#x2F;x86-64)7&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in questa cartella:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - .so sta per shared objects, che sono librerie dinamiche<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - .a sta per le librerie statiche<br>usr - in usr troviamo le cartelle bin, lib, local e include&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -include:&nbsp; contiene tutti i file .h<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -local: il suo contenuto e&#x27; gestito dalla distribuzione di linux (distribuzione = antologia di programmi gestiti in maniera armoniosa (es. debian, fedora etc..). Le distribuzioni sono aggiornate constantemente da una comunita (OPEN SOURCE)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>Pattern Matching in bash<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Wildcard: * qualsiasi stringa (L&#x27;asterisco serve per fare pattern matching con una stringa qualunque)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ????: il numero di punti interrogativi indica quanti caratteri deve avere la stringa con cui facciamo il PM.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?: un carattere qualsiasi, quindi ???? indica 4 caratteri qualsiasi<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !*: ritorna i parametri dell&#x27;ultimo comando chiamato<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ctrl + r + comando: cerca nella history un comando che inizia nello stesso modo<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ls ..&#x2F;*[0-9] mostra i file che terminano per un numero compreso tra 0 e 9<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ls ..&#x2F;[P-T]* prende tutti i file inizianti per P e T(non so se anche lettere comprese)&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br><br>i comandi sono programmi che vengono eseguiti e di solito hanno tre file standard aperti: input, output ed error<br>se non scriviamo nulla, gli standard sono collegati al terminale<br>noi possiamo usare cat hw.c, che fa vedere il file hw.c<br>tabbando vediamo i possibili file<br>posssiamo usare cat in altro modo:&nbsp;&nbsp;&nbsp; cat hw.c &gt; hw2.c ha funzionato come fosse una copia<br>fa un redirezionamento (invece di andare nel terminale) l ha mandato nel file hw2.c<br>Il &#x27;&gt;&#x27; fa un redirezionamento: prende l&#x27;output del comando a sinistra e invece di darlo al terminale lo da al file a destra, copiandolo dentro<br>cat &lt; hw.c &gt; hw2.c : ha redirezionato input e output<br>gedit: file editor di gnome<br>diff hw2.c hw2.c &gt; &#x2F;dev&#x2F;null : il comando ha una funzione booleana, le differenze fra hw e hw2 esistono quindi son &gt; 0, fra hw2 hw2 no quindi torna&nbsp;<br><br>ls &gt; tmp&#x2F;myls : salviamo l&#x27;elenco dei file in un file temporaneo in ordine alfabetico ASCII (prima maiuscole e poi minuscole), pero&#x27; il risultato e&#x27; diverso da ls (ovvero senza formattazione)<br>ls | sort-r : in questo caso abbiamo usato la pipe (operatore | ) e abbiamo unito i due comandi (ls diventa input del successivo)<br>ls | sort -r &gt; cat &#x2F;tmp&#x2F;prova.txt<br>ls | sort -r | sed &quot;s&#x2F;.c$&#x2F; sorgenteC&#x2F;&quot; - questo sed (string editor) permette di cambiare il .c con sorgenteC nel nome del file<br>ls | sort -r | sed &quot;s&#x2F;.c$&#x2F; sorgenteC&#x2F;&quot; | grep sorgenteC - comando di sopra + seleziona solamente la riga con determinate caratterestiche (in questo caso i file con sorgenteC nel nome)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dollaro significa fine della riga in questo caso<br><br>(file in &#x2F;tmp (temporary) cancellati ogni reboot)<br><br>WARNING!!: echo a b c != echo &quot;a b c&quot; (nel primo caso prende 3 paramentri, nel secondo 1)<br>touch &quot;file con spazio&quot;: crea un file di nome &quot;file con spazio&quot;<br>la differenza fra &quot; e &#x27; sta nel fatto che &quot; espande le variabili e simili, mentre &#x27; no.<br>Es. echo &quot;$PATH&quot; stampa il contenuto di PATH, mentre echo &#x27;$PATH&#x27; stampa $PATH<br><br>cat file\ con\ spazio - Il backslash protegge il carattere successivo dall&#x27;interpretazione. Quindi vengono considerati caratteri non speciali: echo \$PATH stampa &quot;$PATH&quot;<br>echo &quot;file con spazio&quot; &gt; nome&nbsp;<br><br>ls | tee &#x2F;tmp&#x2F;1 | tee &#x2F;tmp&#x2F;2 &gt; &#x2F;tmp&#x2F;3 : questi file verranno cancellati ad ogni reboot<br><br>Un backtick (`) (ALT + 96) - non &#232; un segno di citazione. Tutto ci&#242; che digiti tra i backtick viene valutato (eseguito) dalla shell prima del comando principale, e l&#x27;output di quell&#x27;esecuzione &#232; usato da quel comando (essenzialmente l&#x27;output di quel comando fra i due backtick va in input al comando esterno che contiene i backtick.)<br><br>Con &gt;&gt; aggiungi l&#x27;argomento in fondo a un file (in che senso, lo mette proprio in fondo e basta?), col &gt; e basta lo passi solo come input.<br><br>cat ` cat nome ` da errore<br>cat `echo nome`&nbsp; stampa non ho capito cosa<br><br>nano, emacs, vim...etc: editor di testo<br>touch non ti permette di editare, ma se lo usi su un file, risulta che &#232; stato modificato nella data corrente<br><br># LEZIONE DEL 16&#x2F;10&#x2F;2020 ----------------------------------------------------------------------------------------------------<br><br>Continuiamo con i comandi<br>mkdir [nome] - crea una directory di nome [nome]<br>sezione permessi:<br>chmod [ugoa][+-][rwx]: modifica i permessi. u utente, g gruppo, o other (il resto), a all (tutti), +- aggiungi o togli permessi, rwx read write execute. Es :&nbsp;<br>chmod g+w [file] - cambia le informazioni di permesso, aggiungengo i permessi di write per il gruppo al file<br>chmod u + x [file] - aggiunge i permessi di esecuzione (x) per l&#x27;utente al file.<br>pwd - dice la directory corrente<br>~ - indica la root del sistema<br>type [comando] - ci dice il tipo di comando (es. type cd, ci dice che e&#x27; un comando interno)<br>Se un file inizia con #! [comando] il file viene interpretato secondo il comando<br><br>Si possono utilizzare le parentesi quadre per selezionare un range di files (Pattern Matching Bash) es. ls ..&#x2F;[P-T]*<br><br>Quando usiamo la shell, possiamo usare dei metodi per sostituire parti delle stringhe che scriviamo con variabili o con i risultati che danno i comandi. Cio&#x27; e&#x27; possibile grazie alla sostituzione di comando e sostituizione di variabile.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Sostituzione di variabile: viene sostituito cio&#x27; che e&#x27; scritto nella stringa con il valore della variabile a cui si fa riferimento nella stringa stessa (per fare riferimento, si usa $nomeVariabile).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * apici doppi(&quot;_&quot;): effettuano la sostituzione delle variabili<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * apici semplici(&#x27;_&#x27;):&nbsp; stampano la stringa cosi&#x27; com&#x27;e&#x27;, senza fare sostituzioni di variabili. (es. echo &#x27;$nome&#x27; stampa $nome e non Edoardo.)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Per definire variabili alle quali possiamo sostuire il loro valore nelle stringhe,usiamo il comando [nomeVariabile] = [valore] (es. nome=Edoardo da valore a variabile nome, e se scrivo echo &quot;$nome&quot; e ci stampa).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Sostituzione di comando: sostituisce il comando al quale si fa riferimento (con $(nomeComando))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * apice rovesciato (`_`):&nbsp; restituisce l&#x27;output del comando tra virgolette.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * $([comando]) : fa la stessa esatta cosa dell&#x27;apice rovesciato.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Inoltre, $([comando]) permette di lanciare una sotto-shell<br><br>Permessi:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Per cambiare un permesso ai file si possono usare codici numerici in ottale(?) appositi che identificano un determinato&nbsp; insieme di permessi (es chmod 755 [file])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I codici si possono trovare a questo indirizzo: <a href="http&#x3a;&#x2F;&#x2F;www&#x2e;andreaminini&#x2e;com&#x2F;linux&#x2F;permessi&#x2d;numerici&#x2d;su&#x2d;linux" rel="noreferrer noopener">http:&#x2F;&#x2F;www.andreaminini.com&#x2F;linux&#x2F;permessi-numerici-su-linux</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; se il nome del file e&#x27; di colore rosso, e&#x27; molto pericoloso modificarlo (es. &#x2F;usr&#x2F;bin&#x2F;passwd e&#x27; rosso siccome modificandolo cambia la passwd)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; permesso s = file che quando viene aperto si comporta come fosse stato aperto da root<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Una corretta assegnazione dei permessi &#232; importante, un file potrebbe contenere comandi o informazioni fondamentali per il funzionamento del sistema. L&#x27;amministratore (root) ha pieni permessi su tuttto.&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; posso usare le regular expressions anche nella shell... le regular expressions sono espressioni che possono essere riconosciute da automi (o macchine) a stato finito, nomalmente &#232; un argomentio trattato in informatica teorica. - ( <a href="https&#x3a;&#x2F;&#x2F;regex101&#x2e;com" rel="noreferrer noopener">https:&#x2F;&#x2F;regex101.com</a> )<br><br>Comandi in C (la parte che facciamo di solito):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; per i curiosi, perch&#232; &#x27;42&#x27;? : <a href="https&#x3a;&#x2F;&#x2F;simple&#x2e;wikipedia&#x2e;org&#x2F;wiki&#x2F;42&#x5f;&#x28;answer&#x29;" rel="noreferrer noopener">https:&#x2F;&#x2F;simple.wikipedia.org&#x2F;wiki&#x2F;42_(answer)</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include&lt;stdio.h&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int main( int argc, char *argv[] ) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i = (3+2, 10);&nbsp;&nbsp;&nbsp; sta cosa butta via tutto tranne l&#x27; ultima espressione ( i&nbsp; = 10 )&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int len = strlen(argv[1]); &#x2F;&#x2F;ci da la lunghezza del primo argomento inserito.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i, j; &#x2F;&#x2F;in questo caso dichiariamo due variabili e i non viene buttata<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i=0, j=len-1; i&lt;j; i++, j--){ } &#x2F;&#x2F;in questo caso abbiamo un incremento di i e un decremento di j<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *s = &quot;abc\td&quot; &quot;ef\064\n&quot;;&nbsp; &#x2F;&#x2F;stampando s otteniamo abc&nbsp;&nbsp;&nbsp;&nbsp; def4<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#x2F;&#x2F;se abbiamo una stringa molto lunga da scrivere, possiamo quindi chiudere le virgolette e andare a capo senza problemi.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *s = &quot;#include &lt;stdio.h&gt; \n \nint main(){\n\t char *s = %s\n printf(s);\n} &quot;&nbsp;&nbsp; &#x2F;&#x2F;esempio di quine<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 42;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a(void){} non accetta parametri ( da errore )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cool quine:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int main(){char *s = &quot;#include &lt;stdio.h&gt;%cint main(){char *s=%c%s%c;\nprintf(s,10,s);}&quot;;print(s,10,s);}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tutti i linguaggi turing completi permettono un quine<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Le variabili hanno due diversi domini di classificazione: permanenti e locali<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Quando carichiamo in memoria, la parte relativa alle variabili permanenti viene instanziata con il programma e l&#x27;area che occupa la variabile ha gi&#224; il valore iniziale. (In caso di intero se il valore non esiste prende 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esempio:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void a(void){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i=3;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void b(void){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static int andrea;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;%d\n&quot;, andrea);&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int main (){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stampa 3 poich&#232; le variabili locali dichiarate e non inizializzate prendono l&#x27;ultimo valore presente sullo stack anche se han nomi diversi<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Le variabili permanenti (static e le globali) sono inizializzate a 0, le variabili locali no (c&#x27;&#232; un qualche guadagno di memoria)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Se chiamo pi&#249; volte la funzione b modificando la variabile, questa si ricorda del valore precedente e lavora su quello in quanto variabile permanente.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Le variabili eastern indicano che non sono definite nel file sorgente<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Preprocessore:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Define per la definizione di costanti e di macro (utiliziamo le guard per evitare doppie inclusioni)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Include per l&#x27;inclusione dei file<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; In inclusione, le parentesi angolose si usano per includere librerie e le virgolette per file locali<br><br>compilazione:<br>-Wall : Warning all, ovvero, dammi tutte le informazioni di warning relative al programma che ti faccio compilare<br><br>nel main troviamo 2 parametri:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * int argc: numero argomenti<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * char* argv[]: gli argometi effettivi che gli &#x27;&#x27;diamo&#x27;&#x27; quando eseguiamo da command line<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>alias, test e cd sono due comandi builtin<br>ls &#232; un alias<br>gcc invece e&#x27; un comando, hashato a usr&#x2F;bin&#x2F;gcc (ovvero che corrisponde al comando in questo path)<br>test &#232; previsto come shell builtin per efficienza<br><br>Le variabili hanno due diversi domini di classificazione: permanenti e locali<br>Quando carichiamo in memoria, la parte relativa alle variabili permanenti viene instanziata con il programma e l&#x27;area che occupa la variabile ha gi&#224; il valore iniziale. (In caso di intero se il valore non esiste prende 0)<br>Quando carichiamo in memoria, la parte relativa alle variabili permanenti viene instanziata con il programma e l&#x27;area che occupa la variabile ha gi&#224; il valore iniziale. (In caso di intero se il valore non esiste prende 0)<br><br>#IFNDEF ci permette di aggiungere delle compiler flags speicifiche<br>cioe se aggiungo la flag ifndef DEBUG allora se metto la flag -DDEBUG alla compilazioneil codice in ifndef viene eseguito<br><br>le union servono perche ci sono strutture con aree di memoria condivise, e che per questo possono avere significati diversi a seconda del momento, in piu e&#x27; utile per risparmiare spazio.<br><br>esempi:<br>1)<br><br>union un{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t i32;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint8_t i8[4];&nbsp;&nbsp;&nbsp;&nbsp;<br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union un u;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u.i32 = 1040;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint8_t i;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int i=0; i&lt;4; i++){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;%d &quot;, u.i8[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;&nbsp;&nbsp;&nbsp;&nbsp;<br>}&nbsp;<br><br>il codice ritorna 16 4 0 0<br>quella union e&#x27; come scrivere 1040 in int a 32 bit, quello l&#x27;ha letto come un 4 byte.<br>16 4 0 0 sono quindi i &quot;byte&quot;, e 16 e&#x27; il meno significativo (i byte sono disposti al contrario)<br><br>esempio 2:<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>2)<br><br>#include &lt;stdio.h&gt;&nbsp;<br>struct oggetto{&nbsp;<br>&nbsp; int tipo;&nbsp;<br>&nbsp; union{&nbsp;<br>&nbsp;&nbsp;&nbsp; struct {&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char* marca;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int cilindrata;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct {&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int eta;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float peso;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };&nbsp;<br>&nbsp;&nbsp;&nbsp; };&nbsp;<br>&nbsp; };&nbsp;<br>};&nbsp;<br><br>void f(struct oggetto *ogg){}&nbsp;<br><br>enum tipo{AUTO, UMANO};&nbsp;<br><br>int main(){&nbsp;<br>&nbsp; struct oggetto o = {.tipo = AUTO, .marca = &quot;FICA&quot;, .cilindrata = 1000 };&nbsp;<br>&nbsp; struct oggetto o2 = {.tipo = UMANO, .eta = 20, .peso = 70.5};&nbsp;<br>&nbsp; f(&amp;(struct oggetto){.tipo = AUTO, .marca = &quot;FCA&quot;, .cilindrata = 1000 }); &#x2F;&#x2F;abbiamo fatto casting a puntatore per struct oggetto&nbsp;<br>&nbsp; return 0;&nbsp;<br>}<br><br>per C, 0 e&#x27; sempre falso e 1 e&#x27; sempre vero, per qualsiasi struttura dati.<br>Talvolta nel codice troviamo istruzioni come !!x, che utile per convertire una variabile in un valore di verita&#x27; (booleano) 0 o 1.<br><br>in C a volte mettiamo l&#x27;assegnamento nel controllo di ciclo<br><br># LEZIONE DEL 21&#x2F;10&#x2F;2020 ----------------------------------------------------------------------------------------------------<br>Argomenti trattati in questa lezione:<br>- Problemi della concorrenza<br>- Definizioni varie (Atomicit&#224;, Sezione Critica, ...)<br><br>Programmazione concorrente (da concurrent = simultaneo &#x2F; parallelo)<br><br>UNIX non e&#x27; un sistema operativo, bensi uno standard del sistema operativo, con esso si intende cio&#x27; che soddisfa&nbsp; le regole di POSIX (IEEE 1003) (es. 1003.1 sono le system call)<br><br>Per creare simultaneit&#224;, si usano i posix thread (thread in inglese = filo), &#232; come dire che si fa un programma con pi&#249; fili, ci sono piu&#x27; parti che stanno avanzando contemporaneamente.<br><br>Creiamo file mt1.c (multithread 1), editato con &quot;vi mt1.c&quot;<br>Vengono create due funzioni void* p1 e p2 che stampano con un for &quot;Io sono p1 (o p2)&quot; per MAX=10 volte<br>Nel main utilizza il tipo pthread_t per creare gli identificatori del thread tid1 e tid2;<br>pthread_create per creare i thread veri e propri che eseguiranno p1 e p2<br>pthread_join per mettere in attesa il main finch&#232; non finiscono p1 e p2<br>Risultato: vengono eseguiti un po&#x27; di volte p1 e un po&#x27; di volte p2 (senza join termina prima il main del thread)<br><br>Viene aggiunta la variabile int sum;<br>Nei for di p1 e p2 la printf viene sostituita rispettivamente con sum+=1 e sum-=1;<br>Nel main viene richiesto dopo i join di stampare il valore di sum;<br>Risultato: a volte il risultato &#232; -10, altre volte 0 (aumentando il numero di iterazioni da 10 a 100.000 il risultato &#232; praticamente casuale)<br>Per ogni operazione di somma vengono eseguite in realt&#224; tre operazioni:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Viene prelevato il valore di sum e messo nel registro %eax<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Viene aggiunto 1 a %eax<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Viene prelevato il valore di %eax e messo in sum<br>Questo perch&#232; viene passato il controllo da un thread all&#x27;altro durante l&#x27;esecuzione di quelle tre operazioni (anche se sembrano una sola) e il valore che sta calcolando la prima operazione viene sovrascritto dal secondo thread<br><br><strong>bestie nere:</strong><br><ul class="bullet"><li><strong>race condition:</strong> (condizione di gara): il risultato non dipende dal programma scritto ma da come sono succedute le esecuzioni delle operazioni del programma</li><li><strong>starvation:</strong> continuano ad arrivare operazioni ad alta priori&#224; e quelle con priorit&#224; pi&#249; bassa non vengono mai svolte</ul><br>------codice-------<br>#include &lt;stdio.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;pthread.h&gt;<br>#define MAX 10<br><br>int sum = 0;<br><br>void *p1(void *arg){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i=0;i&lt;MAX; i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum += 1;&nbsp; &#x2F;&#x2F;printf(&quot;io sono p1&quot;);&nbsp;&nbsp;&nbsp;<br>}<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>void *p2(void *arg){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i=0;i&lt;MAX; i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum -= 1;&nbsp;&nbsp;&nbsp; &#x2F;&#x2F;printf(&quot;io sono p2&quot;);&nbsp;&nbsp;&nbsp;<br>}<br>&nbsp;&nbsp;&nbsp; int main(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pthread_t tid1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pthread_t tid2; &#x2F;&#x2F;tid sta per thread identifier<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pthread_create(&amp;tid1, NULL,&nbsp; p1, NULL);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pthread_create(&amp;tid2, NULL,&nbsp; p2, NULL);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pthread_join(tid1, NULL);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pthread_join(tid2, NULL);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;%d\n&quot;, sum);<br>}<br><br>Cominciamo a vedere una trattazione piu formale.<br>Per studiare la concorrenza, creaimo un modello che ci consente di rappresentare quello che vogliamo studiare, poi il modello ha due strade, da un lato si usa il modello per rappresentare la conoscenza che ci serve studiare. poi vogliamo far vedere cio&#x27; che questo modello effettivamente rappresenti.<br><br>Abbiamo anche il problema dell&#x27;applicabilita&#x27;: i comandi devono essere chiari e semplici da usare, per poterli usare in maniera comoda.<br><br>Partiamo dalla vita reale: l&#x27;esempio di oggi aveva cambiato significato durante la sua esecuzione.<br>Abbiamo visto che oggi anche il processo ha perso il suo significato, non &#232; pi&#249; l&#x27;istanza restituita dal programma. Parzialmente questo significato pu&#242; essere mantenuto, ma non dobbiamo pi&#249; dare peso al filo del processo. Esso diventa (nell atto pratico) l&#x27;intestatario delle risorse per esguire il programma, il quale ha uno o piu fili esecutivi.<br>La storia esecutiva non &#232; piu singola ma &#232; data dallo stato e dal risultato di ogni filo in ogni istante<br>Nel processo formale vengono distinti due casi<br><br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RACE-CONDITION: quando il risultato non dipende dal programma scritto, ma da come si sono succedute le esecuzioni delle istruzioni del programma, come si sono correlate le varie componenti simultanee. Generalmente &#232; un fattore negativo.<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEADLOCK: In questo caso, si arriva in uno stato in cui nessuna componente del sistema pu&#242; procedere (non ci sono azioni che possono essere eseguite). Solitamente questo fenomeno si verifica perch&#233; un gruppo di componenti attendono reciproci messaggi oppure perch&#232; competono per condividere le risorse presenti nell&#x27;ambiente.&nbsp;<br><ul class="indent"><li>-Livelock: pi&#249; processi non avanzano anche se continuano a compiere azioni (es: persone troppo educate checontinuano a far passare avanti altri)</ul><br>Problematiche di sincronizzazione e di comunicazione sono i principali problemi.<br>Consideriamo atomici gli assegnamenti di costanti, independetemente dal valore della costante.<br><br><strong>Codifica programmi concorrenti:</strong><br><br>xxx process:<br>yyy process:<br>============================<br>aaaaa<br>cobegin<br><ul class="indent"><li>bbbbbbbbb</ul>&#x2F;&#x2F;<br><ul class="indent"><li>ccccccccccc</ul>coend<br>ddddd<br><br>Fare debug con programmi concorrenti &#232; ovviamente pi&#249; difficile che con programmi sequenziali. Abbiamo il determinismo dovuto al fatto di scegliere o meno il processo giusto da seguire, inoltre ci sono le interferenze tra un processo e l&#x27;altro.<br><br>Concetto di invariante:&nbsp;<br>Propriet&#224; di safety: spesso presentata con la frase &quot;Qualcosa di buono di solito succede&quot; (i processi non devono interferire in maniera non voluta)<br>Propriet&#224; di <strong>liveness: </strong>&quot;Qualcosa prima o poi accade&quot;. States that &quot;something good will eventually occur&quot;, contrasting a safety property which states that &quot;something bad does not occur&quot;.<br>Notiamo che sono ortogonali<br><br>Esempio usando un problema di programmazione distribuita (sistemi in cui elaborano molti sistemi indipendenti, che a differenza dei multicore continuano a funzionare anche con uno dei sistemi guasti)<br>Problema del consenso<br>Praticamente abbiamo piu processi che collaborano tra loro e devono arrivare ad accordarsi su un valore nonostante ci possano essere processi che si guastano<br>All&#x27;inizio ogni processo propone un valore, alla fine tutti i processi restituiscono un&nbsp; valore.<br><br><strong>propriet&#224; da rispettare:&nbsp;</strong><br>&nbsp;&nbsp;&nbsp; Tutti devono decidere un valore<br>&nbsp;&nbsp;&nbsp; Il valore risultante deve essere uno tra i proposti<br><ul class="indent"></ul>Se non avessimo una di queste due avremmo dei risultati banali<br>byzantine problem: problema di trovare un accordo tra i diversi componenti di un sistema distribuito<br><br><strong>Sezione critica</strong>: le operazioni vengono eseguite tutte insieme o non viene eseguita nessuna di esse<br><br>&nbsp;&nbsp;&nbsp; <strong>Propriet&#224; per la sezione critica:</strong><br><ul class="bullet"><li>Mutua esclusione:&nbsp; Vogliamo che l&#x27;accesso sia esclusivo. Solo un processo alla volta esegue quel pezzo codice (per&#242; non voglio che si attendano a vicenda) <strong>(safety)</strong></li><li>Non ci deve essere starvation<strong> (liveness)</strong></li><li>No deadlock<strong> (liveness) (scopriremo che alcuni la considerano safety, c&#x27;&#232; un dibattito)</strong><ul class="bullet"><li>quando dei processi si aspettano a vicenda e nessuna fa niente</li><li>Bounded Waiting<strong>:&nbsp;</strong> means that each process must have a limited waiting time. It should not wait endlessly to access the critical section. (soluzione al deadlock).</ul><li>Progress (attesa non necessaria): Se nessun altro vuole accedere alla sezione critica devo potervi accedere(liveness)</ul><br>Questa cosa si pu&#242; implementare? per saperlo ci serve un problema campione.<br>Per vedere se la sezione critica funziona o meno possiamo temporaneamente non curarci della logica operativa.(a cosa serve cio che abbiamo fatto)<br><br>p: process[1..n]:<br>&nbsp;&nbsp;&nbsp; while(true) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#x2F;&#x2F;codice non critico<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; csenter()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#x2F;&#x2F;codice critico<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; csexit()<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; Algoritmo di Dekker (in realta l&#x27;ha scritto Dijkstra)&nbsp;<br>&nbsp;&nbsp;&nbsp; (ha a che fare con un problema che incontriamo in programmazione concorrente)<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#x2F;&#x2F;p e Q sono i processi<br>&nbsp;&nbsp;&nbsp; turn = p<br>&nbsp;&nbsp;&nbsp; p: process<br>&nbsp;&nbsp;&nbsp; while(true)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(turn == Q)<br><ul class="indent"><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pass</li><li>&nbsp;&nbsp;&nbsp; turn = Q</li><li>Q: process</li><li>&nbsp;&nbsp;&nbsp; while(true) {</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(turn == p)<ul class="indent"><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pass</li><li>&nbsp;&nbsp;&nbsp; turn = p</li></ul></li></ul>funziona, ma non rispettiamo la propriet&#224; 4:<br><ul class="indent"><li>se faccio 10k volte -1 e 5k volte +2 a un certo punto si blocca in attessa che l&#x27;altro faccia le sue funzioni, ma l&#x27;altro processo non deve far nulla quindi sprechi tempo.</ul><br>Invece di fare i turni controllo se l&#x27;altro sta elaborando e entro<br><br>(2)<br>inP = false<br>inQ = false<br>&nbsp;&nbsp;&nbsp; p: process<br>&nbsp;&nbsp;&nbsp; while(true)<br><ul class="indent"><li>&#x2F;&#x2F;codice non critico</ul>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(inQ)<br><ul class="indent"><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pass</li><li>&nbsp;&nbsp; inP = true</li><li>&#x2F;&#x2F;codice critico</ul>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inP = false<br><ul class="indent"><li>Q: process</li><li>&nbsp;&nbsp;&nbsp; while(true)&nbsp;<ul class="indent"><li>&#x2F;&#x2F;codice non critico</ul><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(inP)<ul class="indent"><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pass</li><li>&nbsp; inQ = true</li><li>&#x2F;&#x2F;codice critico</li><li>&nbsp; inQ = false</li><li>P dice &quot;Q non ne ha bisogno&quot; e viceversa, quindi escono entrambi dal while</li><li>Potrebbero entrare entrambi nella fase critica contemporaneamente, i booleani non sono esclusivi. =&gt; no mutua esclusione.</ul></li></ul><br><ul class="indent"><li>Eliminando la prima assegnazione dopo il while potremmo avere un deadlock (entrambi dicono &quot;io lo voglio &quot;e rimangono in attesa)</li><li>(3)</li><li>inP = false</li><li>inQ = false</li><li>p: process</li><li>&nbsp;&nbsp;&nbsp; while(true)<ul class="indent"><li><ul class="indent"><li>inP=true</ul><li>&nbsp;&nbsp;&nbsp;&nbsp; while(inQ)<ul class="indent"><li><ul class="indent"><li>inP=false</ul><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pass<ul class="indent"><li>inP = true</ul></li></ul></li></ul><li>&#x2F;&#x2F;codice critico<ul class="indent"><li><ul class="indent"><li>&nbsp;&nbsp;&nbsp; inP = false</ul></li></ul><li>Q: process</li><li>&nbsp;&nbsp;&nbsp; while(true)&nbsp;<ul class="indent"><li>&#x2F;&#x2F;codice non critico<ul class="indent"><li>inQ = true</li><li>while(inP)<ul class="indent"><li>inQ=false</ul><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pass<ul class="indent"><li>inQ = true</ul><li>&#x2F;&#x2F;codice critico</li><li>&nbsp; inQ = false</ul></li></ul></li></ul>Questo da starvation<br>Potremmo avere i processi all&#x27;unisono (improbabile ma possibile)<br>la soluzione 3 &#232; troppo equa, dobbiamo mischiare le soluzioni 1 e 2,<br><br>Soluzione 1- sprechi tempo&nbsp;<br>Soluzione 2- entrambi lavorano<br>Soluzione 3- nessuno lavora<br>Soluzione 4- ok<br><br>qualcuno ha trovato il paper? trovato: <a href="https&#x3a;&#x2F;&#x2F;www&#x2e;cs&#x2e;utexas&#x2e;edu&#x2F;users&#x2F;EWD&#x2F;translations&#x2F;EWD35&#x2d;English&#x2e;html" rel="noreferrer noopener">https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;users&#x2F;EWD&#x2F;translations&#x2F;EWD35-English.html</a> (l&#x27;originale di dekker)<br><br><ul class="indent"><li>(4)</li><li>needP = false</li><li>needQ = false</li><li>turn = P</li><li>p: process</li><li>&nbsp;&nbsp;&nbsp; while(true)<ul class="indent"><li><ul class="indent"><li>&#x2F;&#x2F;codice non critico</li><li>needP=true</ul><li>&nbsp;&nbsp;&nbsp;&nbsp; while(needQ)<ul class="indent"><li><ul class="indent"><li>needP = false</li><li>while (turn&nbsp; == Q)</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pass</li><li>needP = true</ul></li></ul></li></ul><li>&#x2F;&#x2F;codice critico<ul class="indent"><li><ul class="indent"><li>&nbsp;&nbsp;&nbsp; turn = Q</li><li>&nbsp;&nbsp;&nbsp; needP = false</ul></li></ul><li>Q: process</li><li>&nbsp;&nbsp;&nbsp; while(true)&nbsp;<ul class="indent"><li>&#x2F;&#x2F;codice non critico<ul class="indent"><li>needQ = true</li><li>while(needP)<ul class="indent"><li>needQ=false</li><li>while (turn == P)</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pass</li><li>needQ = true</ul><li>&#x2F;&#x2F;codice critico</li><li>turn = P</li><li>needQ = false</ul></li></ul></li></ul><br>risolve mutua esclusione?&nbsp; dimostrazione per assurdo: supponiamo entrambi siano in codice critico, sian riusciti ad entrarci =&gt; sia needP che needQ sono veri. Supponiamo P sia entrato per primo, turno doveva essere P ma perch&#232; Q entri turno deve essere Q. Assurdo.<br><br>Come risolve deadlock? perch&#232; avvenga deadlock servirebbe che entrambi i processi rimangano bloccati in uno dei due while all&#x27; inizio, ma perche siano nel loop occorre che .sia needP che needQ siano veri contemporaneamente, ma &#232; assurdo e uno dei due esce.<br><br>No starvation: mettiamo che p voglia entrare: nel peggiore dei casi Q da il turno a P quando esce, quindi basta aspettare un turno, e non pu&#242; esserci starvation&nbsp;<br><br>Un programma concorrente deve funzionare con tutti i ritardi possibili, se c&#x27;&#232; un solo caso errato allora &#232; tutto sbagliato.<br><br># LEZIONE DEL 23&#x2F;10&#x2F;2020 ----------------------------------------------------------------------------------------------------<br><br>System call<br><br>A volte vengono create nuove syscall ma quelle vecchie vengono lasciate per non toglierle a chi ha creato programmi che le utilizzano<br><br>Un processo quando &#232; &quot;per conto suo (user)&quot; pu&#242; solo fare operazioni aritmetico&#x2F;logiche e salti utilizzando unicamentel&#x27;area di memoria assegnata.<br><br>Strace .&#x2F;file fa uscire un wall of text con tutte le syscall usate per eseguire il codice<br>strace - trace system calls and signals<br>La descrizione del comando dal man strace: In&nbsp; the&nbsp; simplest&nbsp; case <strong>strace</strong> runs the specified command until it exits.&nbsp; It intercepts and records the system calls which are called by a process and the signals which are received by a process. The name of each system call, its arguments and its return value are printed on standard error or to the file specified with the <strong>-o</strong> option.<br><br>Catalogo aree&#x2F;ambiti&#x2F;gruppi di system call (per quali scopi esistono determinate syscall)<br><ol start="1" class="number"><li>&nbsp;Gestione processi</li><li>Esecuzione di programmi</li><li>Gestione della memoria</li><li>File system -&gt; astrazione comoda per accedere ai dati tramite un nome</li><li>File -&gt; operazioni possibili sui files<ol start="1" class="number"><li>Accesso a devices (caso particolare di accesso ad un file)</ol><li>Gestione degli utenti (soprattutto nel caso di sistemi multiutenti (es. Linux) )&nbsp;</ol><ul class="bullet"><li><ul class="bullet"><li>Maschera di login per utente e password = processo in esecuzione come root (accede a tutti i files del sistema) -&gt; se la psw &#232; giusta viene lanciata shell utente (il processo deve cambiare proprietario e per farlo chiede al kernel)</ul></li></ul><ol start="7" class="number"><li>Inter process comunication -&gt; processi comunicano tra loro e si scambiano dati<ol start="1" class="number"><li>&nbsp;sincoronizzazione (tra processi)</li><li>gestione eventi -&gt; il programma aspetta che suceda qualcosa sui file descriptor</ol></li></ol><ul class="bullet"><li><ul class="bullet"><li>es. richiesta di lettura -&gt; sistema si blocca aspettando che qualcuno scriva -&gt; senza gestione eventi non si sa se e dove si sta scrivendo -&gt; gest.eventi segnala attivit&#224;</li><li>A file descriptor is a number that uniquely identifies an open file in a computer&#x27;s operating system. It describes a data resource, and how that resource may be accessed.&nbsp;</ul></li></ul><ol start="5" class="number"><li><ol start="5" class="number"><li>gestione tempo -&gt;&nbsp; no busy wait&nbsp;</ol></li></ol><ul class="bullet"><li><ul class="bullet"><li>ora&#x2F;secondi in maniera precisa (non N cicli = X secondi perch&#232; il processo potrebbe essere interrotto)</ul></li></ul><ol start="7" class="number"><li><ol start="7" class="number"><li>debug &#x2F; profiling(benchmarking) -&gt; misurare prestazioni codice, va chiesto al kernel o a sys call precise</li><li>networking -&gt; es. browser o ssh = comunicazione di rete</ol><li>miscellaneus (varie ed eventuali)</ol><ul class="bullet"><li><ul class="bullet"><li>sys call per il nome della macchina corrente</li><li>sys call per la versione della macchina di kernel</ul></li></ul><br><br>Syscall importanti (man 2 &lt;nomesyscall&gt;)<br>Gestione processi<br>fork<br>Una <strong>fork</strong> in programmazione &#232; la modalit&#224; attraverso cui un processo crea in memoria una copia di se stesso: la copia prender&#224; il nome di processo figlio, mentre il processo originale verr&#224; chiamato processo padre.&nbsp;<br>&quot;fork creates&nbsp; a new process by duplicating the calling process.&nbsp; The new process, referred to as the child, is an exact duplicate of the calling process&quot;<br>Ci&#242; che &#232; in esecuzione viene interrotto e parte il processo di fork<br><br>#include &lt;stdio.h&gt;&nbsp;<br>#include &lt;unistd.h&gt;&nbsp;<br>int main(int argc, char *argv[]){&nbsp;<br>&nbsp; if(fork())&nbsp;<br>&nbsp;&nbsp;&nbsp; printf(&quot;vero\n&quot;);&nbsp;<br>&nbsp; else&nbsp;<br>&nbsp;&nbsp;&nbsp; printf(&quot;falso\n&quot;);&nbsp;<br>}<br>Questo codice restituisce sia vero che falso. Fork rappresenta letteralmente una biforcazione.<br><br>aggiunta di %d .getpid() nella printf<br><br>#include &lt;stdio.h&gt;&nbsp;<br>#include &lt;unistd.h&gt;&nbsp;<br>int main(int argc, char *argv[]){&nbsp;<br>&nbsp; if(fork())&nbsp;<br>&nbsp;&nbsp;&nbsp; printf(&quot;vero %d\n&quot;, getpid());&nbsp;<br>&nbsp; else&nbsp;<br>&nbsp;&nbsp;&nbsp; printf(&quot;falso %d\n&quot;, getpid());&nbsp;<br>}<br>getpid() resituisce il numero identificativo del processo (&#232; in intero, ma non dobbiamo usarlo come intero, bensi come pidtype (pid_t) in modo da non sbagliare nonostante l&#x27;evoluzione dei kernel)<br>Questo codice restituisce vero 18218 e falso 18219 che significa che sono generati da due processi distinti<br>vero rappresenta il processo del padre, falso invece il processo figlio (numero pi&#249; alto)<br><br>getppid() restituisce l&#x27;id del processo padre<br>esempio:<br>#include &lt;stdio.h&gt;&nbsp;<br>#include &lt;unistd.h&gt;&nbsp;<br>int main(int argc, char *argv[]){&nbsp;<br>&nbsp; pid_t pid;&nbsp;<br>&nbsp; if((pid = fork()) != 0)&nbsp;<br>&nbsp;&nbsp;&nbsp; printf(&quot;vero %d %d %d\n&quot;, pid, getpid(), getppid());&nbsp;<br>&nbsp; else&nbsp;<br>&nbsp;&nbsp;&nbsp; printf(&quot;falso %d %d %d\n&quot;, pid, getpid(), getppid());&nbsp;<br>}<br><br>lanciando il programma qui sopra, il primo pid restituir&#224; il process id del comando shell lanciato per l&#x27;esecuzione del programma. Il secondo pid invece sar&#224; 0.<br><br>[per chiedere alla shell il suo process id si scrive echo $$]<br><br>il padre riceve come ritorno della fork l&#x27;identificativo del figlio<br>Il padre pu&#242; avere pi&#249; figli e riceve di volta in volta l&#x27;id dei figli<br>invece ogni processo ha un solo genitore<br><br>Exit()<br>per chiudere un processo invece si usa la sys call _exit&nbsp; (_ perch&#232; esiste gi&#224; funzione di libreria exit)<br>L&#x27;argomento della exit &#232; il valore di ritorno (es. _exit(42))<br><br>Wait()<br>per attendere la terminazione di un processo FIGLIO si utilizza la sys call wait (waitpid())<br>Il primo processo figlio che termina fa svegliare il padre dalla wait<br>la waitpid permette di aspettare singoli processi&nbsp;<br>L&#x27;argomento -1 fa aspettare tutti i processi<br>Di solito i processi ritornano 0 se hanno finito, nella shell 0 &#232; true tutti gli altri valori false&nbsp;<br><br>#include &lt;stdio.h&gt;&nbsp;<br>#include &lt;unistd.h&gt;&nbsp;<br>#include &lt;sys&#x2F;types.h&gt;<br>#include &lt;sys&#x2F;wait.h&gt;&nbsp;<br>int main(int argc, char *argv[]){&nbsp;<br>&nbsp; pid_t pid;&nbsp;<br>&nbsp; if((pid = fork()) != 0){&nbsp;<br>&nbsp;&nbsp;&nbsp; int status;&nbsp;<br>&nbsp;&nbsp;&nbsp; printf(&quot;vero %d %d %d\n&quot;, pid, getpid(), getppid());&nbsp;<br>&nbsp;&nbsp;&nbsp; waitpid(pid, &amp;status, 0);&nbsp;<br>&nbsp;&nbsp;&nbsp; printf(&quot;exit status %d\n&quot;, WEXITSTATUS(status));&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; _exit(0);&nbsp;<br>&nbsp; } else{&nbsp;<br>&nbsp;&nbsp;&nbsp; printf(&quot;falso %d %d %d\n&quot;, pid, getpid(), getppid());&nbsp;<br>&nbsp;&nbsp;&nbsp; sleep(1);&nbsp;<br>&nbsp;&nbsp;&nbsp; _exit(44);&nbsp;<br>&nbsp; }<br>In questo codice il processo padre (l&#x27;if) aspetta la fine del processo figlio(l&#x27;else) che aspetta un secondo prima di terminare.&nbsp;<br><br>&#x2F;&#x2F;2 capitolo system call, da creazione programma a =&gt; esecuzione dei processi<br><br><strong>syscall Exec:</strong><br>esistono varie tipologie di exec.<br>In computing, exec is a functionality of an operating system that runs an executable file in the context of an already existing process, replacing the previous executable.<br><br>execve (*filename, argv[], envp[])prende tre parametri: il file name, un argv (vettore di stringhe) e envp (ovvero l&#x27;ambiente)<br><br>#include &lt;stdio.h&gt;&nbsp;<br>#include &lt;unistd.h&gt;&nbsp;<br>int main(){<br><ul class="indent"><li>char *newargv[] = {&quot;argv[0]&nbsp; di showpid&quot;, NULL};</li><li>printf(&quot;io sono testexecve %d\n&quot; , getpid());</li><li>execve(&quot;.&#x2F;showpid&quot;, newargv, NULL));</ul>}<br><br>exec &#232; una sys call che ritorna se c&#x27;&#232; stato un errore<br>l&#x27;argv[0] per convenzione &#232; il nome del programma lanciato (non sempre)<br><br>#include &lt;stdio.h&gt;&nbsp;<br>#include &lt;unistd.h&gt;&nbsp;<br>int main(){<br><ul class="indent"><li>char *newargv[] = {&quot;argv[0]&nbsp; di showpid&quot;, NULL}</li><li>printf(&quot;io sono testexecve %d\n&quot; , getpid());</li><li>execve(&quot;.&#x2F;showpid&quot;, newargv));</li><li>return 55;&nbsp;</ul>}<br><br>il valore di ritorno della exit viene ritornato al processo genitore<br><br>catalogo delle exec:<br><ul class="indent"><li>exec</li><li>execl</li><li>execlp</li><li>execle</li><li>execv</li><li>execvp - vuol dire che vogliamo che venga usato (scriviamo il path di quello da lanciare)</li><li>execvpe - volgiamo mettere l&#x27;environment</li><li>parentesi: nella libreria c mancava la possibilita di lanciare il comando con la stringa del comando, usando il path proprio.</li><li>molte persone per sopperire al programma usano &#x27;system&#x27;, ma &#232; un errore ed &#232; pericolosissima, in quanto richiama un altra shell. Inoltre &#232; deprecata</li><li>vedere pacchetto alternativo del prof (execs, permette di far girare la stringa del comando senza usare il path e appunto l&#x27;ha fatta il prof (poser)) (che aggiunge alcune exec)</ul><br>Visione degli errori<br><br>le syscall per segnalare un errore<br>tutte ritornato un intero, in gran parte dei casi e&#x27; 0(tutto ok)<br><ul class="indent"><li>se le sys call, ritornano valore negativo (di solito -1) vuol dire che c e stato un errore, ma rimane il problema del sapere quale errore</li><li>per far capire quale errore, esiste una variabile globale a livello di thread (in modo che non ci sia confusione per i vari thread) detta errno...&nbsp;&nbsp; che con un codice ci dice qual &#232; l&#x27;errore che &#232; stato riscontrato</ul><br>i codici di errore di errno sono in &#x2F;usr&#x2F;include&#x2F;asm-generic&#x2F;errno-base.h<br>syscall genera un ernumber che viene poi tradotta in un messaggio testuale (dns vibe)<br><br>C&#x27;&#232; una scritta standard per ogni errore, quindi &#232; bene utilizzare questa tecnica di gestione degli errori&nbsp; anche se di solito si crea una gestione manuale degli errori nel proprio progetto.<br><br>le sys call&nbsp; hanno una documentazione con tutti i valori di ritorno per gli errori ed il relativo significato&nbsp;<br><br>abbiamo detto che il valore di ritorno del processo figlio viene mandato al processo padre, allora abbiamo due casi:<br>&nbsp;&nbsp;&nbsp; 1) il processo padre potrebbe disinteressarsi del processo figlio(non fa la wait per aspettare val di ritorno).<br>&nbsp;&nbsp;&nbsp; 2) il processo padre lancia il processo figlio,&nbsp; e termina prima il processo padre, allora a chi viene mandato il&nbsp; valore di ritorno?<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>Cosa succede se il padre non fa l await del figlio terminato?<br>i processi padre devono aspettare che il processo filgio mandi il segnale di ritorno,&nbsp;<br>se non lo fa il processo figlio non &#232; terminato, e non puo liberare tutte le risorse per il processo padre<br>lo stato Z e&#x27; lo stato zombie, ovvero e&#x27; terminato ma non pu&#242; completare la deallocazione finch&#232; il padre non fa l&#x27;await<br><br>Cosa succede se il processo padre non fa l&#x27;await ed esce?<br>il processo figlio continua a funzionare, e diventa un processo orfano.<br>Un processo orfano manda l&#x27;exit status a un processo 1, ovvero Init, che fa l&#x27;await per tutti i processi orfani.&nbsp;<br><br>Un<strong> processo demone</strong> &#232; caratterizzato dal fatto di eseguire in background per l&#8217;intero periodo di accensione. In sistemi UNIX-like, processi demoni sono avviati da init, o invocati da processi regolari che invocano una fork(), terminano se stessi immediatamente, e passano (implicitamente) il controllo del processo figlio ad init. In tali sistemi il nome di processi demone termina per distinzione in d.&nbsp;<br><br>Con bash lancio un&#x27;altra shell (una sotto shell)<br><br>con export ho passato la variabile alla sottoshell, non viene condiviso bensi&#x27; copiato.<br><br>Parliamo della memoria<br><br>La quantita di memoria disponibile del processo dipende dal punto di rottura dove finisce lo heap<br><br>la memoria dell&#x27;heap non &#232; assegnata in maniera dinamica dal kernel ma dalla libreria del LoP( in C malloc, free,calloc)<br><br>malloc, calloc, free etc gestiscono l&#x27;heap, che manda richieste al kernel<br><br>ha spiegato velocemente la syscall brk&#x2F;sbrk<br><br>brk and sbrk cambiano la locazione del programma brak, che definisce la fine del segmento dati del processo (ovvero la prima locazione dopo la fine di un segmento non inizializzato). Se si aumenta il break si ha l&#x27;effetto di allocare memoria al processo, mentre invece se si diminuisce si dealloca memoria.<br><br>brk setta la fine del segmento dati di un valore specificato nel parametro, sbrk fa la stessa cosa ma prende dei &quot;byte di incremento&quot;<br><br># LEZIONE DEL 28&#x2F;10&#x2F;2020 ----------------------------------------------------------------------------------------------------<br>Argomenti trattati in questa lezione:<br>- algoritmo di Dekker<br>- algoritmo di Peterson<br>- Test and Set<br>- Semafori<br>Lezione di programmazione concorrente<br><br>Riassunto delle puntate precedenti<br>(programmazione) concorrente &lt;--&gt; simultanea<br>Noi stiamo studiando iterazioni portate avanti da entit&#224; che evolvono contemporaneamente<br>Ci possono per&#242; essere interferenze tra le parti che stanno evolvendo anche nelle operazioni pi&#249; semplici<br>(es. somma o sottrazione) in quanto queste sono in realt&#224; insiemi pi&#249; complessi di istruzioni che possono essere interrotte da un altro filo esecutivo.<br>Ci siamo domandati se il problema riguarda solo i sistemi&nbsp; monoprocessore o anche quelli multiprocessore<br>Abbiamo visto che in realt&#224; il problema &#232; similare, quello che ci da fastidio &#232; che le operazioni hanno interferenza dall&#x27;esterno (interrupt o interazioni tra gli altri processori che devono coordinarsi per accedere al bus)<br>Abbiamo visto cosa &#232; atomico e cosa non lo &#232;. (anche se dipende dal processore e dall&#x27;architettura utilizzati)<br>operazioni aritmetiche non sono &quot;atomiche&quot;<br>Assegnamento costanti in macchine RISC pu&#242; non essere atomico&nbsp;<br>Per studiare come fare le cose facciamo riferimento ad un modello in cui prevediamo che sia atomico solo l&#x27;assegnamento di costanti.<br>Un filo esecutivo che pu&#242; progredire nella sua esecuzione lo far&#224;, ma non sappiamo in quanto tempo.<br>La programmazione concorrente non &#232; un gioco a mettere i ritardi oppurtuni per creare le interazioni: vogliamo soluzioni che avanzino correttamente.<br>Perch&#232; si studia la programmazione concorrente nei corsi di SO? perch&#232; la concorrenza viene data proprio dai SO, che inoltre fornisce&nbsp; anche supporto ai processi in esecuzione.<br><br>Tre tipi di processi concorrenti:<br><ul class="bullet"><li><ul class="bullet"><li>Processi che sono ignari l&#x27;uno dell&#x27;altro ma coesistono nel sistema<ul class="bullet"><li>il sistema operativo deve farli coesistere poich&#232; competono nell&#x27;accesso alle risorse =&gt; concorrenza</ul><li>Processi sequenziali e iterativi che sono indirettamente correlati (hanno risorse comuni tipo le pipe)</li><li>Processi che creano thread in base alle necessit&#224; (tipo browser quando si apre una tab)&nbsp;</ul></li></ul><br>La prima domanda &#232;: dato semplicemente il modello fino a questo punto possiamo creare un programma che sia un surrogato di atomicit&#224;?<br>Codice che deve essere eseguito o del tutto o per niente = sezione critica<br>In informatica, una <strong>sezione critica</strong>, anche detta <strong>regione critica</strong>, &#232; una porzione di codice che accede a una risorsa condivisa tra pi&#249; flussi di esecuzione di un sistema concorrente. [wikipedia]<br>Propriet&#224;: no deadlock, no starvation, no ritardi inutili<br><br>Algoritmo di Dekker: algoritmo che risolve il problema della mutex (mutual exclusion, mutua esclusione), gestendo i processi:<br>&nbsp;&nbsp;&nbsp; - evita il deadlock<br>&nbsp;&nbsp;&nbsp; - la sezione critica viene eseguito da un processo alla volta<br><br>*codice*<br>#define MAX 10<br><br>#define P 0<br>#define Q 1<br><br>_Atomic volatile int needp;<br>_Atomic volatile int needq;<br>_Atomic volatile int turn;<br><br>void *p(void *<em>arg</em>) {<br>&nbsp;&nbsp;&nbsp; int i;<br>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; MAX; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#x2F;&#x2F;usleep(random() % 1000);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; needp=1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(needq) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; needp=0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (turn == Q)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usleep(random() % 1000);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; needp=1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;P IN\n&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usleep(random() % 200000);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;P OUT\n&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; needp=0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; turn=Q;<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>void *q(void *<em>arg</em>) {<br>&nbsp;&nbsp;&nbsp; int i;<br>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; MAX; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usleep(random() % 1000);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; needq=1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(needp) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; needq=0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (turn == P)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usleep(random() % 1000);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; needq=1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;Q IN\n&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usleep(random() % 200000);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;Q OUT\n&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; needq=0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; turn=P;<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>Commento al codice<br>usleep(x) = micro sleep: attende x microsecondi<br><br>mutex =mutua esclusione<br>mutex_in: entra in mutua esclusione<br>mutex_out: esce da mutua esclusione<br><br>Vorrebbe far le cose veloci ma &#232; obbligato ad aspettar e il cambio di turno<br><br>delay deterministico &gt; delay statistico -&gt; sembra tutto uguale (non dovrebbe funzionare - starvation)<br><br>se entrambi hanno bisogno della sezione critica, aspetto che entri l&#x27;altro, poi quando lui finisce vado io<br><br>L algoritmo di Dekker non si estende ad N processi, perci&#242; Peterson ha fatto un algoritmo diverso:<br><br>*codice*<br>#include&lt;stdio.h&gt;<br>#include&lt;pthread.h&gt;<br>#include&lt;unistd.h&gt;<br>#include&lt;stdlib.h&gt;<br><br>#define MAX 10<br><br>#define P 0<br>#define Q 1<br><br>_Atomic volatile int needp;<br>_Atomic volatile int needq;<br>_Atomic volatile int turn;<br><br>void *p(void *arg) {<br>&nbsp;int i;<br>&nbsp;for (::) {<br>&nbsp; &#x2F;&#x2F;NC<br>&nbsp; needp=1;<br>&nbsp; turn=Q;<br>&nbsp; while(needq &amp;&amp; turn == P)<br>&nbsp;&nbsp; &#x2F;&#x2F;CRIT<br>&nbsp; needp=0;<br>&nbsp;}<br>}<br><br>void *q(void *arg) {<br>&nbsp;int i;<br>&nbsp;for (::) {<br>&nbsp; &#x2F;&#x2F;NC<br>&nbsp; needq=1;<br>&nbsp; turn=P;<br>&nbsp; while(needp &amp;&amp; turn == Q)&nbsp;<br>&nbsp;&nbsp; &#x2F;&#x2F;CRIT<br>&nbsp; needq=0;<br>&nbsp;}<br>}<br><br>int main(int argc, char *argv[]) {<br>&nbsp;srandom(time(NULL));<br>&nbsp;pthread_t pp;<br>&nbsp;pthread_t pq;<br>&nbsp;pthread_create(&amp;pp, NULL, p, NULL);<br>&nbsp;pthread_create(&amp;pq, NULL, q, NULL);<br>&nbsp;pthread_join(pp, NULL);<br>&nbsp;pthread_join(pq, NULL);<br>}<br><br>Due problemi, due soluzioni<br>Per i sistemi monoprocessor noi abbiamo una maniera per poter fare in modo che cose pericolose possano essere eseguite da processi utente senza causare danni al sistema. Per risolvere questo si utilizza il mascheramento dell&#x27;interrupt.<br>Quest ultimo per&#242; ha due problemi:<br>&nbsp;&nbsp;&nbsp; funziona solo su sistemi&nbsp; monoprocessore<br>&nbsp;&nbsp;&nbsp; permetterebbe ad un singolo processo utente di bloccare tutti gli altri&nbsp;<br>Per risolvere facciamo in modo che il mascheramento dell&#x27;interrupt usi le system call.<br>Nel nostro modello noi abbiamo solo l&#x27;assegnamento come operazione atomica, ma occorre modificarlo per rendere il tutto funzionante:<br><br>Per il secondo problema (sistemi multiprocessore) :<br>&nbsp;&nbsp;&nbsp; La test and set deve essere vista come un operazione atomica<br><br>TS(x.y) &lt; x = Y: Y = 1&gt;<br>Pi : process i = 1....N<br>&nbsp;while (true)<br>&nbsp; &#x2F;&#x2F;non critical code&nbsp;<br>&nbsp; mutex_in()<br>&nbsp; &#x2F;&#x2F;critical code<br>&nbsp; mutex_out()<br><br>global busy = 0<br><br>Pi : process i = 1....N<br>&nbsp;local localcopy;<br>&nbsp;while (true)<br>&nbsp; &#x2F;&#x2F;non critical code&nbsp;<br>&nbsp; &#x2F;&#x2F;mutex_in()<br>&nbsp; do{<br>&nbsp;&nbsp; TS(localcopy, busy)<br>&nbsp; }while (localcopy == 1)&nbsp;&nbsp;<br>&nbsp; &#x2F;&#x2F;critical code<br>&nbsp; &#x2F;&#x2F;mutex_out()<br>&nbsp; busy = 0<br>&nbsp;&nbsp;<br>&nbsp; Questa &#232; una critical section?<br><ul class="bullet"><li><ul class="bullet"><li>mutua esclusione: possono due processi entrare contemporaneamente? no perch&#232; solo uno dei due copier&#224; 0 nella localcopy</li><li>mancanza di attese non necesssarie</li><li>ci pu&#242; essere deadlock? no, perch&#232; non c&#x27;&#232; un attesa ciclica, non si possono attendere a vicenda</li><li>starvation: in realt&#224; &#232; possibile se un processo arriva, prende la critical section e entra, mentre l altro arriva e si mette a ciclare perche la critical section &#232; occupata. Il primo processo esce dalla critical section e vi rientra prima che l&#x27;altro riesca ad entrare (il secondo processo &#232; sfortunato, ma la starvation &#232; comunquepossibile). Esistono modi per mitigare questo difetto: bisogna fare in modo che queste attese siano minimali. (Utilizzare questo algoritmo per attese lunghe &#232; completamente inefficiente, si avrebbe busy waiting)</ul></li></ul>Con alcune difficolt&#224; questo algoritmo &#232; stato implementato anche in sistemi RISC&nbsp;<br><br>Ma se due processi arrivano al test and set con busy uguale a zero?<br>il primo processo arriva e localcopy viene posto a 0 e busy a 1<br>nel secondo processo localcopy uguale a 1,busy resta a 1 e continua a provare ad entrare<br><br>Abbiamo sempre un dato (globale) che identifichi lo stato della critical section<br>Occorre inoltre che ci sia una variabile (locale) che ci faccia capire se prima la critical section era libera ed ora &#232; occupata<br>Se la variabile globale viene utilizzata pi&#249; di una volta l&#x27;algoritmo &#232; sicuramente sbagliato (es. busy compare una volta sola)<br><br>Anche se abbiamo questo algoritmo, abbiamo detto che ci pu&#242; essere busy wait. Inoltre ci sono problemi per cui la sezione critica non &#232; una soluzione.<br>Prendiamo un problema campione e ragioniamo:<br>&nbsp;&nbsp;&nbsp;&nbsp;<br><ul class="indent"><li>&nbsp;&nbsp;&nbsp; Problema di produttore e consumatore (produttore produce dati e consumatore li consuma. Il tutto ordinatamente in modo che i dati non vengano persi e non venga consumato pi&#249; volte lo stesso dato) Per fare ci&#242; si utilizza un buffer:</li><li>dato prodotto viene messo nel buffer e viene prelevato dal consumatore, se per&#242; c&#x27;&#232; bisogno di mettere un secondo elemento nel buffer prima che sia gi&#224; stato preso il primo esso viene perso. Oppure il caso opposto &#232; che venga letto pi&#249; volte lo stesso dato se consumatore accede troppo presto.</li><li>Il consumatore pu&#242; solo leggere dal buffer o utilizzare strutture dati ausiliarie.</li><li>producer: process<ul class="indent"><li>while(true)<ul class="indent"><li>x= produce()&nbsp; &#x2F;&#x2F; non ci interessa come &#232; fatta</li><li>buf = x</ul></li></ul><li>consumer: process<ul class="indent"><li>while (true){<ul class="indent"><li>x = buf</li><li>consume(x)</ul><li>Questa &#232; una descrizione del problema, ma sappiamo che questo codice genera tutti gli errori trattati prima. Abbiamo quindi bisogno di costrutti ed una sintassi pi&#249; completa per consentire di risolvere il problema e che sia implementabile.</li><li>Vogliamo aggiungere elementi che risolvano sia questo problema che la sezione critica</li><li>L&#x27;idea &#232; quella di creare due primitive: p e v (significato: rispettivamente attendi e conferma)</li><li>Le primitive non prendono parametri e non restituiscono nulla</li><li>class semaphore {<ul class="indent"><li>semaphore(init)</li><li>public P(void)</li><li>public V(void)</ul><li>}</li><li>&#x2F;&#x2F; nP e nV rappresentano il numero di chiamate</li><li>invariante -&gt; nP &lt;= nV + init</li><li>invariante (alt) -&gt; nV + init - nP &gt;=0</li><li>&#x2F;&#x2F;se P viene chiamata troppo, l&#x27;invariante diventa falso</li><li>&#x2F;&#x2F;la v puo essere chiamata quando si vuole e serve a decrementare&nbsp;</li><li>semaphore cs(1)</li><li>process pi i=1.....N<ul class="indent"><li>while(true)<ul class="indent"><li>&#x2F;&#x2F;NC</li><li>cs.P()</li><li>&#x2F;&#x2F;C</li><li>cs.V()</ul></li></ul></li></ul></li></ul>In questo caso usiamo il semaforo come la critical section (e appare anche pi&#249; facile del test and set)<br>Ma il semaforo ci da anche qualcosa in pi&#249;:<br><ul class="indent"><li>abbiamo una risorsa disponibile in n unit&#224; (init) ed ogni volta che facciamo una P prendiamo una risorsa, mentre con V la restituiamo</ul>Se inizializziamo il semaforo a zero, ci serve come strumento di sincronizzazione, se si fa la P, il tutto si blocca finch&#232; non c&#x27;&#232; una V. Scriviamo per esempio il produttore-consumatore coi semafori:<br>&nbsp;&nbsp;&nbsp;&nbsp;<br><ul class="indent"><li>semaphore ok2write(1)</li><li>semaphore ok2read(0)</li><li>producer: process<ul class="indent"><li>while(true)<ul class="indent"><li>x= produce()&nbsp; &#x2F;&#x2F; non ci interessa come &#232; fatta</li><li>ok2write.P()</li><li>buf = x</li><li>ok2read.V() &#x2F;&#x2F;abilita ad andare avanti il consumatore</ul></li></ul><li>consumer: process<ul class="indent"><li>while (true){<ul class="indent"><li>ok2read.P()&nbsp; &#x2F;&#x2F;se il consumatore arriva prima si deve fermare</li><li>x = buf</li><li>ok2write.V()</li><li>consume(x)</ul></li></ul></li></ul><br>Caso anomalo: produttore molto veloce e consumatore lento<br>Quando il produttore va a fare ok2write.P() per a seconda volta di fila si ferma (aspettando il consumatore) perch&#232; il valore del semaforo &#232; stato portato a zero<br><br>Livelock: si verifica quando pi&#249; processi non avanzano ma continuando a fare operazioni (come due persone troppo educate che davanti ad una porta continuano a dire &quot;passa prima tu&quot;)<br><br>La speranza massima sarebbe di far gestire la concorrenza da compilatori che fanno tutto da soli (gestiscono la concorrenza senza errori). Ma non potr&#224; mai essere cos&#236;:<br>&nbsp;&nbsp;&nbsp; Poniamo di avere due processi nel mondo ideale<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; y = w = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; p: process<br><ul class="indent"><li>&nbsp;&nbsp;&nbsp; while (true)<ul class="indent"><li>&nbsp;&nbsp;&nbsp; y *= 3</li><li>&nbsp;&nbsp;&nbsp; w *= 3</ul><li>q: process<ul class="indent"><li>while(true)<ul class="indent"><li>y += 2</li><li>w += 2</li></ul></li></ul></li></ul>il programmatore potrebbe voler garantire l&#x27;invariante v == w.<br>Il compilatore dovrebbe decidere qual &#232; la compilazione corretta e qual &#232; quella sbagliata di questo codice, ma possono esserci punti di vista differenti che non prescindono dall&#x27;invariante. Il compilatore non pu&#242; scegliere da solo, bisogna vedere qual &#232;il significato della concorrenza in un determinato caso.<br>Bisogna pensare in modo concorrente.<br><br># LEZIONE DEL 30&#x2F;10&#x2F;2020 ----------------------------------------------------------------------------------------------------<br><br>&nbsp;<br>SYSCALL<br>La volta scorsa abbiamo visto la creazione dell&#x27;astrazione di processo, in UNIX creare un processo ed eseguire un programma sono due cose distinte e indipendenti.<br>Fork crea processi, e quindi lo stato della memoria viene copiato e le variabi li cambiano in entrambe le aree di memoria (padre e figlio)<br><br>All&#x27;esecuzione di un programma non corrisponde la creazione di un processo -&gt; exec mantiene in essere il processo che era in essere al momento della chiamata<br><br>Abbiamo come finisce un processo: _exit e&#x27; la syscall che serve per terminare un processo, e viene sempre eseguita anche se non lo sappiamo.<br><br>C&#x27;e&#x27; un lanciatore che chiama main e ritorna (?) e questo lanciatore che chiama exit e ritorna un valore di ritorno. (Nessun processo muore di morte naturale, solo di omicidio o suicidio)<br><br>Init -&gt; avvio gli altri processi tramite fork, fork &#232; l&#x27;unica syscallc che crea processi. Ne esiste una pi&#249; evoluta chiamata clone().&nbsp; &#200; la fork nella quale vengono suddivisi i vari ambiti di separazione.<br><br><strong>Syscall Clone:</strong> These system calls create a new (&quot;child&quot;) process, in a manner similar to fork. By contrast with fork, these system calls provide more precise control over what pieces of execution context are shared between the calli ng process and the child process.&nbsp; For example, using these system calls, the caller can control whether or not the two processes share the virtual address space, the table of file descriptors, and the table of signal handlers.&nbsp; These system calls also allow the new child process to be placed in separate namespaces<br><br>L unico processo che il boot fa partire &#232; quello che fa partire tutti gli altri fork<br><br>Wait serve per attendere la terminazione di processi o di un processo specifico (Wait e waitpid)<br>Pid = process identifier, ogni processo ne ha uno e lo otteniamo con getpid<br><br>ppid<br>getpgid e setpgid() = funzioni che avranno piu senso una volta visti i segnali.<br>Se io definisco un <strong>process group</strong> di tutti i processi che stanno collaborando a fare un&#x27;elaborazione, posso facilmente mandare comandi a tutti insieme, per esempio per bloccare un&#x27;elaborazione sbagliata, invece che uccidere i processi uno per uno li fermo con un comando solo<br><strong>Section </strong>serve per identificare tutti i processi che fanno riferimento allo stesso terminale<br><br><ul class="indent"><li>The <strong>getpgid()</strong> function shall return the process group ID of the process whose process ID is equal to pid. If pid is equal to 0, getpgid() shall return the process group ID of the calling process.</li><li><em>The <strong>setpgid()</strong> function shall either join an existing process group or create a new process group within the session of the calling process. The process group ID of a session leader shall not change. Upon successful completion, the process group ID of the process with a process ID that matches pid shall be set to pgid. As a special case, if pid is 0, the process ID of the calling process shall be used. Also, if pgid is 0, the process ID of the indicated process shall be used.</em></ul><br>Al giorno d&#x27;oggi <strong>shut down</strong> prova a fare tutti i processi corretti passo passo per far terminare tutti i processi in corso.<br>Quando il kernel vede che non ci sono pi&#249; processi &quot;vivi&quot; spegne il sistema (rimane attivo fino a quando c&#x27;e almeno un processo vivo).<br>Originariamente invece per spegnere Unix si mandava la terminazione &quot;gentile&quot; (15 non 9) a Init<br>kill -15 1 termina prima tutte le &quot;foglie&quot; poi spegne il computer<br><br>citazione cos&#236; scriviamo in parallelo<br>Il <strong>file system</strong> &#232; quella astrazione data dal sistema operativo di docfumenti, pratiche...etc per avere una visione comoda di accesso alla memoria di massa<br><br>in realta trovate che li c&#x27;&#232; semplicemente una sequenza di blocchi contenenti dati, il fatto che possa essere visto come una gerarchia di contenitori &#232; un astrazione<br><br>Molti comandi che abbiamo visto corrispondono a syscall equivalenti<br><br><strong>chdir</strong>()&nbsp; changes the current working directory of the calling process to the directory specified in path.&nbsp;<br><strong>fchdir</strong>() is identical to <strong>chdir</strong>(); the only difference&nbsp; is&nbsp; that&nbsp; the&nbsp; directory&nbsp; is given as an open file descriptor.<br><br>questo concetto di directory corrente e&#x27; uno stato del processo, se noi cambiamo direrctory cambiamo directory al processo<br>Se creiamo un sottoprocesso e cambiamo dir, solo il sottoprocesso cambia dir , ogni processo ha la sua working directory.<br><br>se vogliamo sapere in che directory siamo, c&#x27;&#232; questa chiamata (getcwd o getwd) che e&#x27; una funzione di libreria,&nbsp;<br><br>esiste una getcwd syscall ma ha una&nbsp; signature diversa da quella che rappresenta&nbsp;<br>chdir &#232; anacronistico perch&#232; &#232; un stato del processo ma se l&#x27;architettura &#232; multithread potrebbero verificarsi problemi di concorrenza (es se due thread cambiano directory)<br><br><strong>mkdir </strong>ha due parametri, il secondo sono i permessi<br>esempio da 3.5 secondi (spoiler: dura di pi&#249;):<br>(se una costante viene preceduta da 0 &#232; ottale, 0x esadecimale)<br><br>#include &lt;stdio.h&gt;&nbsp;<br>#include &lt;stdlib.h&gt;&nbsp;<br>#include &lt;unistd.h&gt;&nbsp;<br>#include &lt;sys&#x2F;stat.h&gt;&nbsp;<br>#include &lt;sys&#x2F;types.h&gt;&nbsp;<br><br>void error(char *s){&nbsp;<br>&nbsp; perror(s);&nbsp;<br>&nbsp; exit(1);&nbsp;<br>}&nbsp;<br><br>int main(int argc, char *argv[]){&nbsp;<br>&nbsp; int rv = mkdir(argv[1], 0755);&nbsp; &#x2F;&#x2F;poi cambiati in 0777 (cambia in 755 per motivi di sicurezza) e 0700 (ha messo poi di nuovo 0777)<br>&nbsp; if(rv == -1)&nbsp;<br>&nbsp;&nbsp;&nbsp; error(&quot;mkdir&quot;);&nbsp;<br>&nbsp; rv = chdir(argv[1]);&nbsp;<br>&nbsp; if(rv == -1)&nbsp;<br>&nbsp;&nbsp;&nbsp; error(&quot;chdir&quot;);&nbsp;<br>&nbsp; char *cwd = getcwd(NULL, 0);&nbsp;<br>&nbsp; printf(&quot;%s\n&quot;, cwd);&nbsp;<br>&nbsp; return 0;&nbsp;<br>}<br><br>se io metto l&#x27;umask 022, la regola e&#x27; che quando si apre un file, quei bit accesi nella umask vengono spenti, setto che sono abbastanza magnanimo nell&#x27;accesso in lettura ma non consento quello in scrittura&nbsp;<br><br>e&#x27; un comando che permette di applicare un principio di privilegio minimo<br><br>umask 0077 --&gt; se io eseguo, i permessi saranno 700<br>per cambiare l&#x27;umask, c&#x27;e&#x27; la syscall umask<br><br>concetto di unix e&#x27; il fatto che i file hanno nome e proprieta&#x27; che sono due entita&#x27; differenti, fra le proprieta&#x27; dei file non c&#x27;e&#x27; il nome,&nbsp; e la dir altro non &#232; che un elenco di nomi che indicano file, come se fosse un elenco di puntatori, in realt&#224; sarebbe un elenco di indici, se andiamo a vedere come e&#x27; memorizzata una directory.<br>Ci&#242; che &#232; contenuto nella cartella sono coppie nome + id del file.<br>Data questa astrazione si puo pensare che in pi&#249; directory diverse esistano nomi diversi che indicano lo stesso file, basta fare in modo che la parte numerica della coppia sia uguale (questa operazione si chiama hard link o link fisico). Alla fine ci ritroviamo solo con due nomi per lo stesso file, i quali possono risiedere un dir diverse.<br>Il comando <strong>ln </strong>corrisponde alla sys call<strong> </strong>l<strong>ink</strong>: make a new name for a file<br><br>#include &lt;stdio.h&gt;&nbsp;<br>#include &lt;stdlib.h&gt;&nbsp;<br>#include &lt;unistd.h&gt;&nbsp;<br>#include &lt;sys&#x2F;stat.h&gt;&nbsp;<br>#include &lt;sys&#x2F;types.h&gt;&nbsp;<br><br>void error(char *s){&nbsp;<br>&nbsp; perror(s);&nbsp;<br>&nbsp; exit(1);&nbsp;<br>}&nbsp;<br><br>int main(int argc, char *argv[]){&nbsp;<br>&nbsp; int rv = link(argv[1], argv[2]);&nbsp;&nbsp;<br>&nbsp; if(rv == -1)&nbsp;<br>&nbsp;&nbsp;&nbsp; error(&quot;link&quot;);&nbsp;<br><br>}<br><br>ls -ia -&gt; mostra id file + nome&nbsp;<br>prima crea un file poi crea 2 hard link in modo tale che sia usando uno che usando due io mi riferisco allo stesso file.ls -l uno due<br>sia uno che 1 che 2 fanno riferimento allo stesso id (appunto hard link), dice infatti che ci sono due nomi per lo stesso file<br><br>se io ora facessi&nbsp;<br><br><strong>unlink </strong>toglie un link (duh) quindi la syscall per fare remove&#x2F;delete difatto non esiste, viene autamaticamente cancellato quando succedono due cose:<br>&nbsp;&nbsp;&nbsp; 1) nessun processo lo stia adoperando<br>&nbsp;&nbsp;&nbsp; 2) non ha un nome collegato<br><br>unlink su un file che in quel momento &#232; in uso cancella il nome per accedere a quel file, ma il file continua ad esistere finch&#233; un processo lo sta adoperando, viene cancellato il contenuto quando il processo si chiude.<br>Per esistere un file deve avere un nome, altrimenti poi non esiste pi&#249;.<br><br>Esistono anche i link simbolici:<br><br>#include &lt;stdio.h&gt;&nbsp;<br>#include &lt;stdlib.h&gt;&nbsp;<br>#include &lt;unistd.h&gt;&nbsp;<br>#include &lt;sys&#x2F;stat.h&gt;&nbsp;<br>#include &lt;sys&#x2F;types.h&gt;&nbsp;<br><br>void error(char *s){&nbsp;<br>&nbsp; perror(s);&nbsp;<br>&nbsp; exit(1);&nbsp;<br>}&nbsp;<br><br>int main(int argc, char *argv[]){&nbsp;<br>&nbsp; int rv = symlink(argv[1], argv[2]);&nbsp;&nbsp;<br>&nbsp; if(rv == -1)&nbsp;<br>&nbsp;&nbsp;&nbsp; error(&quot;symlink&quot;);&nbsp;<br><br>}<br><br>un <strong>link simbolico</strong> e&#x27; semplicemente un rimando, infatti se apro 3 viene visualizzato 2 (file del symbolink.)<br><br>se io cancello 2<br><br>int main(int argc, char *argv[]){&nbsp;<br>&nbsp; int rv = unlink(argv[1]);&nbsp;&nbsp;<br>&nbsp; if(rv == -1)&nbsp;<br>&nbsp;&nbsp;&nbsp; error(&quot;unlink&quot;);&nbsp;<br><br>}<br><br>se cancello due, il symlink rimane ma non punta a nulla perche 2 non esiste<br><br>esiste anche la syscall <strong>rename</strong><br>Lo stesso effetto della rename si pu&#242; ottenere facendo un link ad un file con un nome e poi cancellando il vecchio nome:<br><br>int rename(const char *oldpath, const char *newpath);<br>rename()&nbsp; renames&nbsp; a&nbsp; file,&nbsp; moving it between directories if required.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Any other hard links to the file (as created using link(2))&nbsp; are&nbsp; unaf&#8208;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fected.&nbsp; Open file descriptors for oldpath are also unaffected.<br><br>perch&#232; invece la rename &#232; realizzata in maniera separata?<br><ul class="indent"><li>1) atomicit&#224;: vogliamo che in ogni momento o ci sia il vecchio nome o il nuovo, non entrambi.&nbsp;</li><li>2) parliamo di accesso al file system non pensando che pu&#242; essere realizzato in maniera molto diversa: il file system di una chiavetta &#232; di tipo fat e non &#232; capace di fare link fisici, quindi se vogliamo cambiare il nome ad un file rimane la rename che lo sa fare</ul><br>altra cosa: se fate il comando stat di un file, vediamo che ci sono un casino di info, queste sono le info del file.<br><br>se io quindi faccio ln uno due<br>stat due&nbsp;<br>notiamo che INode (Information Node)<br><br>Tramite la syscall stat + argomento otteniamo varie informazioni sul blocco in questione tra cui id, dimensione ultimo accesso ultima modifica ecc.<br>L&#x27;ha testata tramite il codice scritto anche sopra per ottenere la lunghezza del file in questione ( quello in cui ha scritto il codice):<br>#include &lt;stdio.h&gt;&nbsp;<br>#include &lt;stdlib.h&gt;&nbsp;<br>#include &lt;unistd.h&gt;&nbsp;<br>#include &lt;sys&#x2F;stat.h&gt;&nbsp;<br>#include &lt;sys&#x2F;types.h&gt;&nbsp;<br><br>void error(char *s){&nbsp;<br>&nbsp; perror(s);&nbsp;<br>&nbsp; exit(1);&nbsp;<br>}&nbsp;<br><br>int main(int argc, char *argv[]){&nbsp;<br>&nbsp; struct stat buf;&nbsp;<br>&nbsp; int rv = stat(argv[1], &amp;buf);&nbsp;<br>&nbsp; if(rv == -1)&nbsp;<br>&nbsp;&nbsp;&nbsp; error(&quot;stat&quot;);&nbsp;<br>&nbsp; printf(&quot;%ld\n&quot;, buf.st_size);&nbsp;<br>&nbsp; return 0;&nbsp;<br>}<br><br>molte syscall a partire dallo stat sono disponibili nella formula stat, lstat e fstat<br>La differenza sta che la lstat prende i link symboli come pacchi<br>la fstat invece come trasparente.<br><br>infatti se aggiungo lstat, due diventa lungo 5 e tre invece e&#x27; lungo 3 caratteri, questo perch&#232; il file 2 contiene &quot;ciao&quot; =&gt; 5 caratteri contando l&#x27; a capo.<br>il file 3 &#232; un link simbolico a 2, ma il contenuto vero del file tre &#232; &quot;due&quot; ovvero il nome del file a cui punta.&nbsp;<br>La lunghezza di un file link ha la lunghezza di tutto il path che gli dai per poter arrivare al file linkato quindi non &#232; lungo quanto il file puntato ma quanto il path.<br><br>Per i file aperti, se abbiamo i file aperti abbiamo un descrittore di file, se abbiamo un file spento bisogna fare fstat, infatti fstat prendere pure un intero (che e&#x27; il file descriptor) e&#x27; un identificatore.<br><strong>Identificatore:</strong> viene restituito quando si apre un file, serve per nominare tutti i file senza bisogno di ogni volta ridare i pathname. Dopo una open (che &#232; un&#x27;operazione complessa) viene salvato l&#x27;iter e si tengono le informazioni necessare per gestire la &quot;pratica&quot; in questione finch&#232; tale file non viene chiuso.<br><br>possiamo usare fd anche per avere altre info anche quelle della stat, e quindi se voglio le info<br><br><strong>chown</strong>() <u>ch</u>anges the <u>own</u>ership of the file specified by pathname, which is dereferenced if it is a symbolic link.<br>chown: change ownership, server per cambiare l&#x27;ownership (owner o group) mettendo -1 solo nel valore che vuole cambiare.<br><br>chmod cambia la modalita&#x27; d&#x27;accesso (permessi etc, ma l&#x27;abbiamo gia visto)<br><br><strong>int</strong> <strong>truncate(const</strong> <strong>char</strong> <strong>*</strong>path<strong>,</strong> <strong>off_t</strong> length<strong>);</strong><br>The&nbsp; <strong>truncate</strong>()&nbsp; and&nbsp; <strong>ftruncate</strong>() functions cause the regular file named by path or referenced by fd to be truncated to a size of precisely length bytes.<br><br>truncate = tronca un file<br>Pu&#242; essere usata per estendere un file: se applichiamo una truncate di 1 M ad un file lungo 1 K, otteniamo un file di 1 M dove la parte che abbiamo esteso &#232; piena di byte a &quot;0&quot;.<br>In realta la truncate non alloca sempre tutto lo spazio, semplicemente perche i file di unix possono avere dei buchi, possono esserci aree (parliamo di blocchi) del file non allocati, in tal caso vengono letti come se fossero completamente pieni di zeri.<br>Dunque se scrivi qualcosa viene allocato, altrimenti risulta pieno di zeri.<br><br><strong>int</strong> <strong>mount(const</strong> <strong>char</strong> <strong>*</strong>source<strong>,</strong> <strong>const</strong> <strong>char</strong> <strong>*</strong>target<strong>, const</strong> <strong>char</strong> <strong>*</strong>filesystemtype<strong>,</strong> <strong>unsigned</strong> <strong>long</strong> mountflags<strong>, const</strong> <strong>void</strong> <strong>*</strong>data<strong>);</strong><br><strong>mount</strong>()&nbsp; attaches the filesystem specified by source (which is often a pathname referring to a device, but can also be the pathname of a&nbsp; directory&nbsp; or&nbsp; file,&nbsp; or&nbsp; a dummy&nbsp; string)&nbsp; to&nbsp; the location (a directory or file) specified by the pathname in target.<br><br>contrariamente a tanti altri sistemi operativi, unix ha un&#x27;unica gerarchia. Se ho piu dischi quindi, l&#x27;idea e&#x27; che dobbiamo fare in modo che il sottoalbero della nostra unita secondaria (es. chiavetta) compaia sotto l&#x27;albero grande della unita principale. l&#x27;utente normalmente non puo fare questa operazione la puo fare solamente root.<br><br>rega io ora mi sposto su hackMD<br><a href="https&#x3a;&#x2F;&#x2F;hackmd&#x2e;io&#x2F;&#x40;ODccqFFKQtS2v7p0G43ysQ&#x2F;sisop" rel="noreferrer noopener">https:&#x2F;&#x2F;hackmd.io&#x2F;@ODccqFFKQtS2v7p0G43ysQ&#x2F;sisop</a><br><br>E&#x27; come se la dir vuota fosse come un&#x27;ancora dove agganciamo l&#x27;albero di ci&#242; che andiamo a montare<br>Se la dir su cui montiamo non &#232; vuota il contenuto sottostante risulterebbe inaccessibile, perch&#232; quando arriviamo a navigare nalla dir mount, noi di fatto entriamo in una gerarchia che &#232; nel filesys montato.<br><br>&#x27;su&#x27; serve per cambiare utente e diventare un utente diverso, se non c&#x27;&#232; scritto nulla si intende root&nbsp;&nbsp;<br>root pu&#242; impersonificare ogni utente del suo sistema<br>&#x27;su -&#x27; il <strong>-</strong> serve per dire fai finta che abbia fatto login come root, quindi leggiti tutti i file di configurazione di root<br><ul class="indent"></ul><strong>&#x27;</strong>sudo<strong>&#x27; </strong>(super user do) serve per fare un&#x27;orepazione come se fossi root<br>mentre su chiede la password di root perch&#232; il comando permette di diventare la root, sudo &#232; una forma delegata. L&#x27;idea &#232; nata per permettere alla root di delegare compiti ad altri utenti<br><br><strong>&#x27;</strong>cado<strong>&#x27; </strong>(capability do) consente di abilitare utenti solo a funzionalit&#224; precise, ad esempio fare shutdown, poter avere connessioni di rete come server, etc.<br><br>Il file system tipici del monod linux sono col nome &quot;EX&quot; davanti.<br>Possiamo prendere la chiavetta di tipo ex4&nbsp;<br><br>Getdents =&gt; non &#232; quello che vogliamo usare, il manuale ti dice che &#232; molto pesante.&nbsp;<br>Tramite myls si pu&#242; vedere che i file di una directory vengono elencati in maniera strana, inq uanto son salvati in un heap e vengono visualizzati nel modo pi&#249; comodo a lui per raggiungerli.<br><br>while ((getdents(d, (struct linux_dirent *) buf, DIRBUFSIZE)) &gt; 0)<br><br>il while getdents continua a entrare nelle sottodirectory finche non ne trova piu<br>poi se non erro restituisce null<br><br>open e&#x27; una syscall particolare perche ha 3 parametri di cui il terzo sara&#x27; solo se il file viene creato&nbsp;<br><br><br><br>(?)<br><br><br><br><strong>File System</strong><br>Il file system &#232; quella astrazione data dal sistema operativo di documenti, pratiche...etc per avere una visione comoda di accesso alla memoria di massa<br><br><strong>gestione delle directory</strong><br>Esistono chiamate di sistema dedicate alla gestione delle directory, tra le quali&nbsp;<br><ul class="indent"><li>mkdir() crea una nuova directory&nbsp;</li><li>rmdir() rimuove una directory, solo se vuota&nbsp;</li><li>chdir() sostituisce la directory corrente del processo con quella indicata come argomento&nbsp;</li><li>getcwd() restituisce il percorso della directory corrente.</li><li>openat() specifica (indirettamente, tramite il primo parametro) il percorso da utilizzare come nuova directory corrente</li><li>getdents():&nbsp;</li><li>opendir(), openfdir(), readdir(), rewinddir()</li></ul>&#200; possibile effettuare operazioni sulle directory tramite file descriptor come su file. Per riuscirci &#232; sufficiente invocare open() con il suo percorso come argomento<br><br>Ovviamente anche le directory sono (e devono essere) vincolate da permessi.<br><br><strong>Alcune System call per la gestione del file system</strong><br><br>Il link<br>In Unix i file hanno nome e propriet&#224; che sono due entit&#224; differenti, tra le propriet&#224; del file non c&#x27;&#232; il nome.<br>La path del file &#232; come fosse un puntatore al file stesso.<br>In pi&#249; directory diverse possono esistere quindi due nomi diversi che si riferiscono allo stesso file (hard link)<br>Per fare questa cosa si usa il comando &#x27;ln&#x27;, che corrisponde alla sys call &#x27;link&#x27;<br>Utilizzo di ln:<br>&nbsp;&nbsp;&nbsp; ln&nbsp; [OPTIONS] &#x27;FILE&#x27; &#x27;LINK&#x27;<br>Anche se cos&#236; pu&#242; sembrare, il secondo file non &#232; una copia del primo, ma un suo alias<br>Per l&#x27;eliminazione del link si usa unlink, infatti andiamo a cancellare il nome per accedervi e non il file stesso.<br>Questo ovviamente se il file non &#232; in uso, altrimenti l&#x27;eliminazione avviene alla chiusura.<br>Esistono anche i link simbolici ( soft links ) che necessitano dell&#x27;opzione -s.<br>Differenza tra hard e soft link:<br><ul class="indent"><li><em>Soft links are similar to shortcuts, and can point to another file or directory in any file system.</em></li><li><em>Hard links are also shortcuts for files and folders, but a hard link cannot be created for a folder or file in a different file system.</em>&nbsp;<em> [freecodecamp]</em></ul><br>La system call &#x27;rename&#x27;<br>Esiste anche la sys call &#x27;rename&#x27;, banalmente potremmo creare un link ad un file con un nuovo nome e poi cancellare il vecchio link, ma allora perch&#232; creare la rename? Per l&#x27; atomicit&#224; (la stessa atomicit&#224; di cui parliamo in programmazione concorrente), per ordine (evitare la creazione di duplicati) e per motivi implementativi, dovuti anche al tipo di file system che stiamo utilizzando (ad esempio alcuni potrebbero non essere in grado di realizzare link fisici).<br><ul class="indent"><li>rename [OPTIONS] &#x27;FILE&#x27;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li><li>link di collegamento alle options:</li><li><a href="https&#x3a;&#x2F;&#x2F;www&#x2e;howtogeek&#x2e;com&#x2F;423214&#x2F;how&#x2d;to&#x2d;use&#x2d;the&#x2d;rename&#x2d;command&#x2d;on&#x2d;linux&#x2F;" rel="noreferrer noopener">https:&#x2F;&#x2F;www.howtogeek.com&#x2F;423214&#x2F;how-to-use-the-rename-command-on-linux&#x2F;</a></ul><br>La system call &#x27;stat&#x27;<br>&quot;aggiungere breve descrizione&quot;<br><ul class="indent"><li>stat [OPTIONS] &#x27;FILE&#x27;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li><li>link di collegamento alle options:</li><li>&nbsp;<a href="https&#x3a;&#x2F;&#x2F;www&#x2e;howtogeek&#x2e;com&#x2F;451022&#x2F;how&#x2d;to&#x2d;use&#x2d;the&#x2d;stat&#x2d;command&#x2d;on&#x2d;linux&#x2F;" rel="noreferrer noopener">https:&#x2F;&#x2F;www.howtogeek.com&#x2F;451022&#x2F;how-to-use-the-stat-command-on-linux&#x2F;</a></li></ul>La system call &#x27;chown&#x27;<br>&quot;aggiungere breve descrizione&quot;<br>Si trova nelle forme chown, lchown, fchown, fchownat<br><ul class="indent"><li>chown [OPTIONS] &#x27;FILE&#x27;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li><li>link di collegamento alle options:</li><li><a href="https&#x3a;&#x2F;&#x2F;linuxize&#x2e;com&#x2F;post&#x2F;linux&#x2d;chown&#x2d;command&#x2F;" rel="noreferrer noopener">https:&#x2F;&#x2F;linuxize.com&#x2F;post&#x2F;linux-chown-command&#x2F;</a></li></ul>La system call &#x27;chmod&#x27;<br>&quot;aggiungere breve descrizione&quot;<br><ul class="indent"><li>chmod [OPTIONS] &#x27;FILE&#x27;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li><li>link di collegamento alle options:</li><li><a href="https&#x3a;&#x2F;&#x2F;www&#x2e;howtogeek&#x2e;com&#x2F;437958&#x2F;how&#x2d;to&#x2d;use&#x2d;the&#x2d;chmod&#x2d;command&#x2d;on&#x2d;linux&#x2F;" rel="noreferrer noopener">https:&#x2F;&#x2F;www.howtogeek.com&#x2F;437958&#x2F;how-to-use-the-chmod-command-on-linux&#x2F;</a></li></ul>La system call &#x27;truncate&#x27;<br>&quot;aggiungere breve descrizione&quot;<br><ul class="indent"><li>truncate [OPTIONS] &#x27;FILE&#x27;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li><li>link di collegamento alle options:</li><li><a href="https&#x3a;&#x2F;&#x2F;linoxide&#x2e;com&#x2F;linux&#x2d;how&#x2d;to&#x2F;use&#x2d;truncate&#x2d;command&#x2d;linux&#x2F;" rel="noreferrer noopener">https:&#x2F;&#x2F;linoxide.com&#x2F;linux-how-to&#x2F;use-truncate-command-linux&#x2F;</a></li></ul>La system call &#x27;mount&#x27;<br>&quot;aggiungere breve descrizione&quot;<br><ul class="indent"><li>mount [OPTIONS] &#x27;FILE&#x27;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li><li>link di collegamento alle options:</li><li><a href="https&#x3a;&#x2F;&#x2F;www&#x2e;geeksforgeeks&#x2e;org&#x2F;mount&#x2d;command&#x2d;in&#x2d;linux&#x2d;with&#x2d;examples&#x2F;" rel="noreferrer noopener">https:&#x2F;&#x2F;www.geeksforgeeks.org&#x2F;mount-command-in-linux-with-examples&#x2F;</a></ul><br>La system call &#x27;getdents&#x27;<br>getdents(Gli dobbiamo passare un&#8217;istanza della struct linux_dirent ) restituisce la lista di files della directory in un formato indipendente dal file system, ma &#232; molto pesante da usare. La dicitura<em> Look at readdir(3) for the POSIX-conforming C library interface</em> che troviamo all&#x27;interno del manuale ci reindirizza alla funzione C readdir([DIR]), che restituisce un puntatore alla directory in input.<br><br>La system call &#x27;open&#x27;<br>La funzione open() apre il pathname predisponendolo per le operazioni di I&#x2F;O come indicato dai flags.<br><ul class="indent"><li>int open( const char *pathname, int flags, mode_t mode )</li><li>Link di collegamento ai flag:</li><li><a href="https&#x3a;&#x2F;&#x2F;digilander&#x2e;libero&#x2e;it&#x2F;uzappi&#x2F;C&#x2F;librerie&#x2F;funzioni&#x2F;open&#x2e;html" rel="noreferrer noopener">https:&#x2F;&#x2F;digilander.libero.it&#x2F;uzappi&#x2F;C&#x2F;librerie&#x2F;funzioni&#x2F;open.html</a></li></ul>contrariamente a tanti altri sistemi operativi, unix ha un&#x27;unica gerarchia.<br>&nbsp;Se ho piu dischi quindi, l&#x27;idea e&#x27; che dobbaimo fare il modo che il sottoalbero della nostra unita secondaria (es. chiavetta) compaia sotto l&#x27;albero grande della unita principale.&nbsp;<br>&nbsp;L&#x27;utente normalmente non puo fare questa operazione la puo fare solamente root.<br><br><strong>Super user e permessi</strong><br>&#x27;su&#x27; per accedere ai permessi di &#x27;super user&#x27; (amministratore, root).<br>&#x27;sudo&#x27; (super user do) per effettuare un unica operazione (quella del comando corrente) come super user.<br>access() (deprecata) -&gt; ritorna ok o errore se quel permesso &#232; consentito o no<br><br>copia dei file con system call:<br>&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;<br>&nbsp;&nbsp;&nbsp; #include &lt;stdlib.h&gt;<br>&nbsp;&nbsp;&nbsp; #include &lt;unistd.h&gt;<br>&nbsp;&nbsp;&nbsp; #include &lt;fcntl.h&gt;<br>&nbsp;&nbsp;&nbsp; #include &lt;stdint.h&gt;<br>&nbsp;&nbsp;&nbsp; #include &lt;sys&#x2F;stat.h&gt;<br>&nbsp;&nbsp;&nbsp; #include &lt;sys&#x2F;types.h&gt;<br>&nbsp;&nbsp;&nbsp; #define CPBUFSIZE&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; void error(char *s){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror(s)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><br>&nbsp;&nbsp;&nbsp; int main(int argc, char*argv[]){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint8_t buff[CPBUFSIZE]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int fdin, fdout;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ssize_t len<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct stat, sbuf<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fdin = open(argv[1], = 0_RDONLY);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(fdin == -1) error(&quot;open in&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fdout = open(argv[2], 0_WRONLY |&nbsp; 0_CREAT | 0_TRUNC, 0777 )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(fdout == -1) error(&quot;open out&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><ul class="indent"><li>&#x2F;* codice aggiunto dopo: (ci fornisce un buffer della grandezza ottimale invece di definirlo (sostituire) )<ul class="indent"><li>int rv = fstat(fdout, &amp;sbuf)</li><li>if(rv == -1) error(&quot;fstat&quot;)</li><li>blksize_t blksize = buf.st_blksize;</li><li>vint8_t buf[blksize];</ul><li>*&#x2F;</ul>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while((len = read(fdin, sbuf, CPBUFSIZE )) &gt; 0) &#x2F;&#x2F;quando la risposta &#232; zero il file &#232; finito<br><ul class="indent"><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write(fdout, buf, len)</ul>&nbsp;&nbsp;&nbsp; }<br><br>L&#x27;efficienza di questo programma dipende dall&#x27;ampiezza del buffer. &#232; un tradeoff, pi&#249; grande &#232; il buffer meno tempo ci mettiamo (ovviamente con una bassa differenza quando si sale molto con la dimensione del buffer)<br><br><br><br>cosa succede ai file aperti durante una fork?<br>&nbsp; #include &lt;stdio.h&gt;<br>&nbsp;&nbsp;&nbsp; #include &lt;stdlib.h&gt;<br>&nbsp;&nbsp;&nbsp; #include &lt;unistd.h&gt;<br>&nbsp;&nbsp;&nbsp; #include &lt;fcntl.h&gt;<br>&nbsp;&nbsp;&nbsp; #include &lt;stdint.h&gt;<br>&nbsp;&nbsp;&nbsp; #include &lt;sys&#x2F;stat.h&gt;<br>&nbsp;&nbsp;&nbsp; #include &lt;sys&#x2F;wait.h&gt;<br>&nbsp;&nbsp;&nbsp; #include &lt;sys&#x2F;types.h&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; void error(char *s){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror(s)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; int main(int argc, char*argv[]){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; fdout;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int status;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fdout = open(argv[2], 0_WRONLY |&nbsp; 0_CREAT | 0_TRUNC, 0777 )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(fdout == -1) error(&quot;open out&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#x2F;*codice aggiunto dopo<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dup2(fdout,STDOUT_FILEN0);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&#x2F;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch(fork()){<br><ul class="indent"><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0:<ul class="indent"><li><ul class="indent"><li>write(fdout, &quot;CIAO\n&quot;, 5);</li><li>exit(0);</ul><li>default:<ul class="indent"><li>write(fdout, &quot;MARE\n&quot;, 5);</li><li>wait(&amp;status)</ul><li>case -1:<ul class="indent"><li>exit(0);</ul></li></ul></li></ul>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; stampa :<br>&nbsp;&nbsp;&nbsp; MARE&nbsp;<br>&nbsp;&nbsp;&nbsp; CIAO<br><br># LEZIONE DEL 04&#x2F;11&#x2F;2020 ----------------------------------------------------------------------------------------------------<br>Argomenti trattati in questa lezione:<br>- semafori<br>- problema del produttore e consumatore<br>- problema dei filosofi a cena<br>- problema degli scrittori e consumatori<br><br>Concorrente non vuol dire solo parallelismo ma anche poter vedere dal punto di vista del processo quello che succede negli altri processi. Pensare di impersonarsi volta per volta in uno dei processi coinvolti e vedere cosa succede<br><br>Non &#232; possibile fare programmazione concorrente con dei metodi meccanici ma &#232; necessario ragionare avvalendosi di alcune metodologie per risolvere alcuni problemi specifici<br>Sono stati creati una gamma di problemi &#x27;campione&#x27; stereotipati per vedere se siamo in grado di risolverli<br><br>Abbiamo visto che l&#x27;atomicit&#224; del sistema non ci basta, dobbiamo rendere atomico anche ci&#242; che il sistema non ci da come tale<br>Abbiamo visto soluzioni semplici ma che sono pesantissime, e non riuscirebbero a rendere utilizzabile la programmazione concorrente in casi di stress.<br><br>riprendendo l&#x27; invariante del semaforo visto la scorsa volta:<br><br><ul class="indent"><li><ul class="indent"><li>nP &lt;= init + nV</li><li>class semaphore {<ul class="indent"><li>semaphore(init)</li><li>void P(void)</li><li>void V(void)</ul><li>}</li><li>semaphore mutex(1)</li><li>while(true) {<ul class="indent"><li>&#x2F;&#x2F;codice non critico</li><li>mutex.P()</li><li>&#x2F;&#x2F;codice critico</li><li>mutex.V()</ul><li>}</ul></li></ul><br>P e V non hanno n&#232; parametri n&#232; valori di ritorno<br>P() non &#232; critico<br>V() &#232; critico<br>SAFETY -&gt; RISOLTA<br>Safety: il numero di P completate diventa 1 entrando nella sezione critica, se esce porta nV a 1, vale che 1 &lt;= 2, il che poi rimane uguale aumentato sempre di 1 sia a sx che dx.<br><br>concetto del valore del semaforo:<br>basta solo scrivere&nbsp;<br>init + nV -c -nP &gt;= 0 (valore del semaforo)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>quello che abbiamo scritto &#232; un vincolo (un po come in ottimizzazione) perch&#232; non possiamo scrivere &quot;il valore del semaforo non pu&#249; essere bla bla...&quot;<br><br>il valore del semaforo pero e&#x27; un&#x27;astrazione( errato dire &quot;il valore del semaforo in questo momento &#232;:&quot;, non ha il segmento che permette l&#x27;accesso al semaforo. Inizialmente il valore del semoforo e&#x27; 1, ma quando entra nella sezione critica e&#x27; 0<br><ul class="indent"></ul>DEADLOCK<br>&nbsp;se abbiamo una implementazione del semaforo, allora l intera struttura &#232; deadlock free.<br>STARVATION:<br>Non &#232; garantita dall&#x27;invariante<br>motivazione presente negli appunti della scorsa volta<br>Occorre una regola in pi&#249;<br><br>Sono semafori fair quelli che oltre l&#x27;ivariante garantiscono che i processi che si mettono in attesa verranno risvegliati in ordine FIFO<br><br>&#x2F;&#x2F;Quando il prof parla di semafori, se non specifica parla di semafori generali e fair; altrimenti lo scrive.<br><br>soltita storia di produttore e consumatore<br><br>*CODICE DEL SEMAFORO SOPRA*<br>process producer:&nbsp;<br>&nbsp;&nbsp;&nbsp; while(1)<br><ul class="indent"><li>x = produce()</li><li>buf = x</li></ul>process consumer<br><ul class="indent"><li>while 1<ul class="indent"><li>y = buf</li><li>consume(y)</ul></li></ul><br>se implementassi questa cosa avrei risk condition a gogo<br>es: se abbiamo un produttore un molto rapido, questo produttore continuera a sovrasscrivere il buffer e quindi verrano persi elementi (???)<br>La critical section da sola non basta a risolvere il problema (&#232; una sincronizzazione pi&#249; elaborata<br><br>abbiamo visto che pero questo metodo e paradigma dei semafori consente di risolvere il problema (lol ok)<br><br>semaphore empty(1)<br>semaphore full(0)<br>shared buf<br><br>process producer:&nbsp;<br>&nbsp;&nbsp;&nbsp; while(1)<br><ul class="indent"><li>x = produce()</li><li>p(empty)</li><li>buf = x</li><li>V(full)</li></ul>process consumer<br><ul class="indent"><li>while 1<ul class="indent"><li>p(full)</li><li>y = buf</li><li>V(empty)</li><li>consume(y)</ul></li></ul><br>trova che il semaforo full e&#x27; 0<br>se arriva prima il consumatore si ferma<br>se arriva prima il produttore produce (ma non pu&#242; produrre due pezzi senza che il primo venga prima consumato)<br>usati in questo modo i semafori servono per segnalare una condizione<br>inizialmente il buffer &#232; vuoto<br>per poter mettere un valore nel buffer occorre che sia vuoto<br>mentre per poter leggere un valore dal buffer dobbimo aspettare che sia pieno<br>una volta che abbiamo inserito un elemento in buffer possiamo indicare che il buffer e&#x27; pieno e viceversa se il buffer e&#x27; vuoto<br><br>a sto punto abbiamo due strade:<br><ol start="1" class="number"><li>&nbsp; andare a vedere altri problemi</li><li>&nbsp;fermarci un attimo, &quot;ci piaccioni sti semafori ma li possiamo implementare in un sistema operativo, come possiamo fare?&quot;</ol><br>Partiamo da 2)<br><br>PSEUDOCODE:<br>class semaphore {<br><ul class="indent"><li>private value;</li><li>&#x2F;&#x2F; coda dei processi bloccati</li><li>private queue semq;</li><li>void semaphore(init) {<ul class="indent"><li>mutex_in();&nbsp;</li><li>value = init;</li><li>mutex_out();</ul><li>}</li><li>void P(void) {<ul class="indent"><li>mutex_in();</li><li>if (value &gt; 0) {</li><li>&nbsp;&nbsp;&nbsp; value--;</li><li>} else {<ul class="indent"><li>&#x2F;&#x2F; si blocca il processo corrente</li><li>readyq.remove(current);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li><li>semq.enqueue(current);</li><li>mutex_out();</ul><li>}</ul><li>}</li><li>void V(void) {<ul class="indent"><li>mutex_in();</li><li>&#x2F;&#x2F; controlla se ci sono processi bloccati</li><li>if (!semq.empty()) {<ul class="indent"><li>&#x2F;&#x2F;sblocca il primo</li><li>proc = semq.dequeue;</li><li>readyq.enqueue(proc);</ul><li>} else {<ul class="indent"><li>value++;</ul><li>}</li><li>mutex_out();</ul></li></ul>&nbsp;&nbsp;&nbsp; }<br>}<br>Commento:<br>P -&gt; *mutex_in* se value &gt; 0 diminuisce value di 1&nbsp; - altrimenti blocca il processo corrente *mutex_out*<br>V -&gt; *mutex_in* Se ci sono processi bloccati sblocca il primo -&nbsp; altrimenti incrementa value di 1 *mutex_out*<br>Per implementare il ramo else di P usa:<br>- readyq.remove(current)<br>- semq.enqueue(current)<br>Per implementare il ramo if di V usa:<br>- !semq,empty()<br>- proc = semq.dequeue()<br>- readyq.enqueue(proc)<br><br>Tornando all&#x27;esempio del cuoco di inizio corso:<br>In un sistema multitasking la cpu viene assegnata a turno alla coda dei processi pronti, quindi per fare in modo che un processo non avanzi basta toglierlo dalla coda dei processi ready, quando invece un processo deve essere risvegliato basta metterlo nella coda ready.<br>Come implementare mutex_in e out?<br>1. In un sistema monoprocessore bisogna usare le interruzioni: mutex_in disabilita interruzioni e mutex_out riabilita le interruzioni.<br>2. In un sistema multiprocessore usiamo la test and set.<br>Dimostrazione della &quot;fairness&quot; per assurdo<br>Il processo A quando fa la V, la V torner&#224; sempre prima siccome &#232; una coda fifo.<br>che cosa ci guadagno a usare i semafori implementati cosi per fare mutua esclusione quando potrei farla con la test and set? cosa cambia?<br>cambiano due cose fondamentali<br>1) non c &#232; busy wait perche se usiamo la P e la V non c&#x27;e nessuno che sta li ad aspettare. la test and set lo fa invece.<br>prendiamo un processo che si blocchi perch&#232; non c&#x27; &#232; mutua esclusione<br>Tutti fanno busy waiting<br>invece fare mutex_in significa:<br>{<br><ul class="indent"><li>mutex.P</li><li>sl_in ---- QQQ ----- sl_out (con --- QQQ --- si intende che lavora sulle code, sl = spinlock)&nbsp;</li></ul>}&nbsp;<br>-&gt; mutex_out :<br>{<br>&nbsp;&nbsp;&nbsp; mutex.V();<br><ul class="indent"><li>sl_in --- QQQ --- sl_out</ul>}<br><br>nel momento in cui vengono eseguiti i comandi in mutex in&#x2F;out c&#x27;&#232; busy waiting<br>ma con l&#x27;implementazione del semaforo fatto poco fa lo spinlock e&#x27; attivo solo nel tempo in cui si mette un elemento fra una e l&#x27;altra, se arrivasse qualcuno a fare una operazione allora fa spinlock. Nel momento in cui fa questo pero non c&#x27;e&#x27; busywait, l&#x27;idea e&#x27; che e&#x27; vero che si puo fare mutua esclusione a livello utente, ma non ci conviene perch&#232; facciamo busy wait a livello utente<br><br>noi quindi facciamo una mutua esclusione con spinlock o interrupt, e usaimo spinlock per cambiare le struttre dati del kernel, ma i tempi di attesa non comportano busy wait.<br><br>rispetto alla fairness c&#x27;&#232; una precisazione da fare (seppur moolto piccola)<br>in realta qualcuno potrebbe dire che in un caso speciale non e&#x27; fifo, perche e&#x27; fifo per il primo che riesce a prendere quella mutex, e non sempre.<br>&#232; talmente marginale che non lo prendiamo in consideraione, dura infatti solo una decina di istruzioni, e quindi se anche il processore cicla una decina di volte non si ha una perdita di performance alta.<br><br>linux ha i comandi up and down, che sono esattamente P e V, quindi questi sono i semafori implementati nel kernel di linux.<br>Ci sono anche le implementazioni delle spinlock<br><br>Andiamo a vedere se possiamo risolvere altri problemi<br>1) complichiamo da due punti di vista il producer cosumer, rendiamolo producerS &#x2F; consumerS<br><ul class="indent"><li>Consideraimo consumer e producer come array da 1 a n</li><li>tutti gli elementi prodotti vengono consumati? Si, perche&#x27; se ci sono 12 produttori, il primo che arriva mette elementi nel buffer, gli altri si fermano, un consumatore lo eliminer&#224; e il secondo avr&#224; successo e andra avanti.</ul>2) buffer limitato.<br><ul class="indent"><li>invece di avere un solo elemento nel buffer condiviso c &#232; un array di elementi</li><li>le regole son semrpre le stesse, se un produttore produce una certa seq di elementi il consumatore consuma sempre la stessa sequenza, non ci devono essere elementi persi n&#232; elementi letti pi&#249; volte.</li><li>basta modificare il valore di empty alla nuova dimensione del buffer (con BUFSIZE)</li></ul>3) producerS consumerS + buffer limitato<br><ul class="indent"><li>queue e dequeue non sono atomiche</li><li>se due produttori vogliono inserire un elemento del buffer abbimo visogno di mutua esclusione</li><li>occorre quindi un ulteriore semaforo che si occupa della mutua esclusione.</li></ul>Regola aurea sull&#x27;uso dei semafori: ovunque ci siano variabili condivise esse devono essere accedute (accesso al buffer) in mutua esclusione (non abbiamo atomicit&#224;).<br><br>Esempio reale del problema del consumatore e produttore:<br>Le schede audio DSP devono consumare i dati con regolarit&#224;&nbsp; e quindi quando ascoltiamo qualcosa (specialmente online) viene creato un buffer per inviare i dati al DSP con regolarit&#224;.<br><br>Digressione sulla definizone di invariante:<br>L&#x27;invariante e&#x27; qualcosa che non varia, che deve essere vera<br>&#232; una propriet&#224; che deve essere mantenuta<br>da chi, per una libreria, una struttura o altro, in questo caso trattiamo di una libreria:<br>noi scriviamo una espressione che ha alla fine un valore booleano. Dato l&#x27;invariante, questo deve essere sempre vero quando le funzioni sono state sempre valutate.<br>p.e. Un invariante dello stack: pop(push(x)) = x, questo appunto vale sempre<br>L&#x27;importante &#232; che durante la valutazione della funzione non ci interessa che l&#x27;invariante venga modificato, l&#x27;importante &#232; che all&#x27;inizio e alla fine il valore sia mantenuto<br>venga mantenuto<br><br>prima di chiamare le funzione di una classe l&#x27;invariante deve essere vero, quando le ha eseguite<br><br>esiste una libreria di macro detta sert, e la sert consente di metterre a sert una espressione booleana.&nbsp;<br>es. Non deve mai succedere che il puntatore sia diverso da null<br><br>torniamo alla lezione di oggi:<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>Esercizio di Dijkstra (Hore)<br><ul class="indent"><li><strong>La cena dei filosofi</strong> (dining philosopher) (vedere su google che non ho voglia a scrivere)</li><li><a href="https&#x3a;&#x2F;&#x2F;www&#x2e;tutorialspoint&#x2e;com&#x2F;dining&#x2d;philosophers&#x2d;problem&#x2d;dpp&#x23;&#x3a;&#x7e;&#x3a;text&#x3d;The&#x25;20dining&#x25;20philosophers&#x25;20problem&#x25;20states&#x2c;they&#x25;20eat&#x25;20and&#x25;20think&#x25;20alternatively&#x2e;&amp;text&#x3d;A&#x25;20philosopher&#x25;20needs&#x25;20both&#x25;20their&#x2c;there&#x25;20are&#x25;20both&#x25;20chopsticks&#x25;20available" rel="noreferrer noopener">https:&#x2F;&#x2F;www.tutorialspoint.com&#x2F;dining-philosophers-problem-dpp#:~:text=The%20dining%20philosophers%20problem%20states,they%20eat%20and%20think%20alternatively.&amp;text=A%20philosopher%20needs%20both%20their,there%20are%20both%20chopsticks%20available</a>.</ul><br>un filosofo fa due cose:<br>&nbsp;&nbsp;&nbsp; pensa e mangia.<br><br>I filosofi non rispettano le norme anti covid e siedono ad un tavolo rotondo con 5 piatti e 5 forchette; mangiano spaghetti ma visto che nessuno gli ha insegnato a mangiare come si dovrebbei gli servono DUE forchette per mangiare gli spaghetti; le forchette sono poste alla loro sinistra e alla loro destra in modo che non possano mangiare in due contemporaneamente, se non hanno entrambi le forchette, vanno in starvation.<br>Una rappresentazione che possiamo dare del probelma vede le forchette di sx e di dx come risorse che devono essere prese per mangiare e poi rilasciate.<br><br>I semafori sono strutture dati quindi si possono fare code, vettori ecc di semafori<br><br>Tentativo di risoluzione con codice:<br>&nbsp;&nbsp;&nbsp; semaphore chopstick[5] int (1,1,1,1,1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#x2F;&#x2F;vettore di 5 semafori inizializzati a 1<br><ul class="indent"><li>process philo(i), i = 0...4</li><li>while 1:<ul class="indent"><li>&#x2F;&#x2F;think</li><li>chopstick[i].P()</li><li>chopstick[(i+1) % 5].P()</li><li>&#x2F;&#x2F;eat</li><li>chopstick[i].V()</li><li>chopstick[(i+1) % 5].V()</ul></li></ul><br>p = prendere la bacchetta<br>v = lasciare la bacchetta<br>Le chopstick sono 5 risorse, il filosofo i-esimo prende la bacchetta a sx (stesso indice del filosofo) e quella a destra, le forchette sono in cerchio e vanno da 0 a 4.<br>Se tutti i filosofi diventano affamati nello stesso momento abbiamo una deadlock perch&#232; tutti cercano di prendere la seconda bacchetta occupata dal filosofo accanto quindi muoiono di fame ma non per starvation (occhio alla traduzione) ma per la deadlock.<br>Il problema di questo problema &#232; la troppa simmetria, ad esempio non ci sarebbero probelemi se un filosofo fosse mancino e prendesse per prima la forchetta alla sua dx (non ci sarebbe pi&#249; la deadlock)<br><br>questa soluzione risolve il problema? No perch&#232; tutti vogliono accedere assie tutti i filosofi diventano affamati nello stesso momento abbiamo deadlock: tutti aspettano che la risorsa si liberi ma nessuno mangia. Rip<br><br>tutti i 5 quindi muiono di fame (non &#232; una starvation LOL)<br>come risolvere? il problema &#232; nella troppa simmetria<br><br>soluzione:<br>Supponiamo ci sia un filosofo mancino<br>facendo cosi gia non c&#232; pi&#249; deadlock<br><ul class="indent"><li><ul class="indent"><li>process philo(i), i = 0...3</ul><li>while 1:<ul class="indent"><li>&#x2F;&#x2F;think</li><li>chopstick[i].P()</li><li>chopstick[(i+1) % 5].P()</li><li>&#x2F;&#x2F;eat</li><li>chopstick[i].V()</li><li>chopstick[(i+1) % 5].V()</li></ul><li>process philo(i), i = 4</li><li>while 1:<ul class="indent"><li>&#x2F;&#x2F;think</li><li>chopstick[(i+1) % 5].P()&nbsp;</li><li>chopstick[i].P()</li><li>&#x2F;&#x2F;eat</li><li>chopstick[(i+1) % 5].V()</li><li>chopstick[i].V()</li></ul></li></ul>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1<br>&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><br>0 prende la forchetta 0<br>1 prende la forchetta 1<br>2 prende la forchetta 2<br>3 prende la forchetta 3<br>4 prenderebbe la forchetta 0 gi&#224; presa da 0 (alla sua sx)<br><br>Se il filosofo 4 fosse destrorso dovrebbe prendere la forchetta 4 che sarebbe libera<br><br>2 filosofi avrebbero condiviso tutte le risorse<br>3 filosofi era un caso particolare perch&#232; ogni filosofo aveva risorse condivise con gli altri<br>4 filosofi dava spazio a soluzioni simmetriche del tipo i pari fanno una cosa i dispari un&#x27;altra<br>5 &#232; il numero minimo di filosofi che richiede una soluzione asimmetrica&nbsp;<br><br>altro problema<br><strong>problema dei lettori e degli scrittori</strong><br>Ci sono processi lettori e processi scrittore. Processi condivido struttura dati, per&#242; la strutt dati pu&#242; essere letta contemporaneamente da pi&#249; lettori senza produrre alcuna interferenza. Invece <u>non pu&#242; essere scritta mentre</u> ci sono dei lettori che stanno lavorando, e neanche quando ci sono altri scrittori che stanno lavorando.<br>se contiamo quelli che stanno scrivendo, possiamo avere un numero arbitrario di lettori oppure un solo scrittore<br><br>prendiamo una banale lista, per aggiungere un elemento dobbiamo fare una serie di operazioni sui puntatori, ma nel frattempo se qualcuno sta scorrendo la lista potrebbe trovare cose strane<br><br>stessa cosa per la lattura dei file<br><br>process reader[i] 1...tanti &#x2F;&#x2F;sono tanti lettori<br><ul class="indent"><li>....</li><li>beginread()&nbsp;</li><li>read</li><li>endread()</li></ul>processs writer[i] i tanti!!!<br><ul class="indent"><li>....</li><li>beginwrite()</li><li>write</li><li>endwrite()</ul><br>detti nr = numero lettori attivi, nw numero scrittori attivi<br><br>(nw == 0 &amp;&amp; nr &gt;= 0) | | (nr == 0 &amp;&amp; nw == 1)&nbsp;<br><br>Tre casi:<br>&nbsp;&nbsp;&nbsp; Lettori in quantit&#224;<br>&nbsp;&nbsp;&nbsp; 1 scrittore senza lettori<br>&nbsp;&nbsp;&nbsp; 0 scrittori e 0 lettori<br><br>proviamo a cercare una soluzione usando un semaforo con due stati: o uno scrittore solo o tanti lettori.<br>Quindi &#232; un semaforo o occupato da uno scrittore o da tanti lettori.<br><br>&#x2F;&#x2F;se prendiamo da soli gli scrittori, questi assomigliano un sacco a una critical section&nbsp;<br>quindi aggiungiamo questo codice:<br><ul class="indent"><li>semaphore rw(1)</li><li>beginwrite:<ul class="indent"><li>rw.P()</li><li>nw++</ul><li>endwrite:<ul class="indent"><li>nw--</li><li>rw.V()</li></ul></li></ul><br>&#x2F;&#x2F;piccolo reminder: essenzialmente, quando si fa P aspetti, quando fai V parti (come appunto un semaforo)<br><ul class="indent"><li>semaphore rw(1)</li><li>semaphore mutexr(1)</li><li>beginread:<ul class="indent"><li>mutexr.P() &#x2F;&#x2F; a un semaforo che vale 1 quando vien fatta la P passo lo 0, quindi&nbsp; mutex diventa 0</li><li>if nr==0:&nbsp; rw.P() &#x2F;&#x2F;quando rw = 0, rw.P() rimane in attesa</li><li>nr++</li><li>mutexr.V()</li></ul><li>endread:<ul class="indent"><li>mutexr.P()</li><li>nr--</li><li>if nr==0: rw.V()</li><li>mutexr.V()</li></ul><li>beginwrite:<ul class="indent"><li>rw.P() &#x2F;&#x2F;qui c&#x27;e&#x27; lorenzo</li><li>nw++</ul><li>endwrite:<ul class="indent"><li>nw--</li><li>rw.V()</ul></li></ul><br>quando si fa la V, mutexr diventa 0<br>l&#x27;invariante e&#x27; verificato? si perche si ha nel primo caso nr &gt;= 0<br><br>il nostro scrittore e&#x27; in attesa<br><br># LEZIONE DEL 06&#x2F;11&#x2F;2020 ----------------------------------------------------------------------------------------------------<br><br><strong>Riepilogo episodi precedenti:</strong><br>Nella prima puntata (23&#x2F;10&#x2F;2020) abbiamo visto:<br>- delle sys call per creare l&#x27;astrazione di processi (creata tramite la fork, che &#232; storicamente l&#x27;unica in grado di creare processi clonandoli dal processo padre ma con valore di ritorno diverso).<br>- Per aspettare i valori di ritorno si utilizza la wait.<br>- Pper terminare il processo si usa la exit.<br>La scorsa volta (30&#x2F;10&#x2F;2020) abbiamo visto sys call che riguardano il file system:<br>- mkdir per creare una directory (vuota).<br>- rmdir cancella una directory (vuota), altrimenti per cancellare una gerarchia di directory possiamo usare -r (recursive).<br>- Ci sono gerarchie tra file descritte da nome del file e file system<br>- Il link simbolico non &#232; altro che un segnaposto che indica a chi cerca un file in un path di ridirezionare l&#x27;attenzione verso un altro path. Si possono fare rimandi a file inesistenti o che non esistono pi&#249; o addirittura tra file system differenti.<br>Altri riferimenti ad episodi precedenti: vedere le sys call fatte nella scorsa lezione.<br><br><strong>Domande 06&#x2F;11&#x2F;2020 e implementazione di una shell</strong><br>- Quando si chiama fork, la memoria del processo &#232; privata (es. non si puo usare per la programmazione concorrente siccome un processo non puo prendere le variabili dell&#x27;altro).<br>- Quando si chiama un processo non &#232; il sistema operativo a fare la fork ma la shell<br>- Esempio di shell minimale:<br><br><ul class="indent"><li>#include&lt;stdio.h&gt;</li><li>#include &lt;stdlib.h&gt;</li><li>#include &lt;execs.h&gt;&nbsp; &#x2F;&#x2F;nota: la execs va importato come pacchetto, altrimenti si pu&#242; usare la execve</ul><br><ul class="indent"><li>int main(int argc, char *argv[]) {<ul class="indent"><li>char* line = NULL;</li><li>size_t linelen = 0;</li><li>for(;;) {<ul class="indent"><li>int status;</li><li>pid_t pid;</li><li>printf(&quot;prompt&gt; &quot;);</li><li>fflush(stdout);</li><li>if(getline(&amp;line, &amp;linelen, stdni) &lt;= 0 ) &#x2F;&#x2F;getline() ritorna il numero di caratteri letti; -1 se fallisce<ul class="indent"><li>break;</ul><li>switch(pid = fork()) {</li><li>case 0:<ul class="indent"><li>execsp(line);</li><li>exit(255);&nbsp; &#x2F;&#x2F;evito che diventi una forkbomb assicurandomi che esca</ul><li>default:<ul class="indent"><li>waitpid(pid, &amp;status, 0);</li><li>break;</ul><li>case -1:<ul class="indent"><li>break;</ul><li>}</li><li>printf(&quot;cmd %s\n&quot;, line);</ul><li>}</li><li>if(line)&nbsp; free(line);</li><li>return 0;</ul><li>}</ul><br>Tale codice funziona solo per l&#x27;esecuzone di programmi, ad esempio:<br>- &#x27;cd .. &#x27; non funziona<br>- &#x27;echo&#x27; funziona&nbsp;<br>- manca l&#x27;autocompletamento<br><br>se volessi implementare la ridirezione di output dovrei farlo all&#x27;inizio del case 0, inserendo questo codice (<strong>attenzione</strong>, bisogna includere &lt;fnctl.h&gt;):<br><br><ul class="indent"><li>char *greatherthan;</li><li>int f;</li><li>if(greatherthan = strchr(line, &#x27;&gt;&#x27;) != NULL ) {<ul class="indent"><li>*greatherthan++ = 0;</li><li>while(*greatherthan == &#x27; &#x27;) gratherthan++;</li><li>char *nl = strchr(line,&#x27;\n&#x27;);</li><li>if(*nl != NULL) *nl = 0;</li><li>f = open(greatherthan, O_WRONLY | O_CREAT, | O_TRUNC, 0777);</li><li>if(f &gt;= 0) {<ul class="indent"><li>dup2(f, STDPUT_FILENO);</li><li>close (f);</ul><li>}</ul><li>}</ul><br><strong>Syscall stat</strong><br>- `ftsat` info su un file aperto. Usa file descriptor<br>- `lstat` info sul link<br>- `stat` info su file in genere. Se usato su un link, da info sul file puntato dal link<br><br>access():<br>&nbsp;&nbsp;&nbsp; per verificare se si hanno permessi di accesso al file.<br>&nbsp;&nbsp;&nbsp; In genere il controllo dei permessi e il successivo accesso vanno fatti in maniera atomica.<br><br>umask = maskeriamo i bit etc ma labbiamo gia visto cosi come truncate quindi suca<br><br>EPISODIO DI OGGI S1E12 (6&#x2F;11&#x2F;20)<br><br>Unix &#232; filesystemcentrico e utilizza il file system per dare un nome a tutto<br><br><strong>file descriptor</strong><br>un File Descriptor (FD, meno frequentemente fildes) &#232; un indicatore astratto (handle) utilizzato per accedere a un file o un&#x27;altra risorsa di input &#x2F; output, come una pipe o un socket di rete.<br>Di alcuni file rimane solo il descrittore che indica che si tratta di file speciali e vuole nominare un device usando una coppia di numeri (minore e maggiore).<br>Il maggiore indica al kernel a quale device driver si fa riferimento<br>254 &#232; il driver dei dischi virtuali sul computer del prof<br>il gestore dei terminali gestisce appunto molti terminali, il numoero della gestione terminale &#232; 4 (modulo), mentre il numero dello specifico terminale &#232; dato dal numero minore<br><br><br>esistono file speciali di tipo carattere, e file speciali a blocchi che interagiscono scambiando i blocchi, allora se esistono sti file speciali, qualcuno li deve aver creati, ad esempio i terminali vengono gestiti da dei base drivere che sono stati caricati come numero 4, ma il gestore dei terminali gestisce tanti terminale e il terminale (??) e&#x27; dato dal minor number... es vdb ha numero 16 e vdb1 numero 17<br><br>echo ciao &gt; dev&#x2F;pts&#x2F;2 lo scrive sul terminale dev&#x2F;pts&#x2F;2<br><br>uso il terminale come se fosse un file, ma in realta io chiedo al device 136 di aprirmi lunita 2 e questo mi accede alla seconda finestra.<br><br>quindi i file permettono di accedere a questa unita (fun fact: questo e&#x27; il motivo per cui non puoi chiamare un file CON su windows)&nbsp;<br><br>come si fa a creare un file speciale?&nbsp; &#x2F;&#x2F;ricordati di fare sta domanda eminem<br>Un file speciale non e&#x27; un vero e proprio file, non ha una estensione, il file descriptor lo segna come un file speciale a causa del suo contenuto, aka il kernel lo &quot;usa&quot; in base a se ce scritto che e&#x27; un file speciale nel file descriptor o no.<br><br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;&nbsp;<br>#include &lt;fcntl.h&gt;&nbsp;<br>#include &lt;unistd.h&gt;&nbsp;<br>#include &lt;sys&#x2F;types.h&gt;&nbsp;<br>#include &lt;sys&#x2F;stat.h&gt;&nbsp;<br>#include &lt;sys&#x2F;sysmacros.h&gt;&nbsp;<br><br>int main(int argc, char *argv[]){&nbsp;<br>&nbsp; dev_t devno = makedev(atoi(argv[2]), atoi(argv[3]));&nbsp;<br>&nbsp; mknod(argv[1], S_IFCHR | 0777, devno);<br>&nbsp; &#x2F;&#x2F; chmod(argv[1], 0666);&nbsp;<br>}<br><br>strace !-2 --- (ritorna a due comandi fa)<br><br>The&nbsp; system&nbsp; call&nbsp; <strong>mknod</strong>() creates a filesystem node (file, device special file, or named pipe) named pathname, with attributes specified by mode and dev.<br><br><br>lseek()<br>serve per riposizionsrsi all&#x27;interno del file<br><a href="https&#x3a;&#x2F;&#x2F;www&#x2e;man7&#x2e;org&#x2F;linux&#x2F;man&#x2d;pages&#x2F;man2&#x2F;lseek&#x2e;2&#x2e;html" rel="noreferrer noopener">https:&#x2F;&#x2F;www.man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;lseek.2.html</a><br><br>se io voglio scrivere qualcosa in una determinata posizione del file, ma un altro therad contemporaneamente vuolefare una cosa simile, abbiamo un problema di atomicit&#224; e il risultato potrebbe non essere quelllo voluto<br><br>per risolvere il problema del lseek, ci sono pread e pwrite<br><a href="https&#x3a;&#x2F;&#x2F;man7&#x2e;org&#x2F;linux&#x2F;man&#x2d;pages&#x2F;man2&#x2F;pread&#x2e;2&#x2e;html" rel="noreferrer noopener">https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;pread.2.html</a><br><a href="https&#x3a;&#x2F;&#x2F;www&#x2e;man7&#x2e;org&#x2F;linux&#x2F;man&#x2d;pages&#x2F;man2&#x2F;pwrite&#x2e;2&#x2e;html" rel="noreferrer noopener">https:&#x2F;&#x2F;www.man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;pwrite.2.html</a><br><br>questi non chiedono solo un descrittore, un buffer e una lunghezza, ma anche &#x27;a partire da quale posizione nel file volete che venga fatta l&#x27;operazione&#x27;<br><br>queste operazoioni accedono in punti diversi del file (per questo ho un offset)<br><br>pwritev preadv, sono pread e pwrite vettoriali.<br>cosa cambia dalla read e la write vettoriali?<br><br>mettiamo che vogliamo scrivere dei dati, ma questi non sono in un buffer unico, noi quindi potremmo fare due write diverse, ma in questo modo ci interferiamo a vicenda, in piu e&#x27; pure costoso (syscall in generale lo sono).<br>Lo stesso concetto si ha quando vengono spediti dei pacchetti in rete, anche li la comunnicazione di rete verra vista come un file, ma ora il pacchetto avra la testata dei vari protocolli etc dell&#x27;incapsulamento, quindi invece di&nbsp;<br><br>iov ha due campi, indirizzo base e lunghezza, a seconda di quanti buffer e&#x27; composto il dato che vogliamo scrivere (?????)<br><br>readv e writev sono fatit in maniera atomica (o tutto o niente), l&#x27;alternativa sarebbe fare un buffer unitorio, ma si perde tempo, quindi cio esiste per evitare queste situazione.<br><br><br>di quasi tutte le sys call viste per la gestione del file system esistono versioni che terminano con &#x27;at&#x27;, ad esempio<br><br>(openat (sorella di open) etc chownat etc) come primo parametro queste syscall hanno un filedescriptor di una directory... essenzialmete ci serve a specificare quale sia la current working directory..<br><br>nella open tra i vari paramentri che possiamo mettere c &#x27;&#232; CLOEXEC, che erve a chiudere il file nel momento della exec<br><br>la scansione infatti incomincia dalla posizione della working directory (se scelgo positione relativa)<br><br>per questo motivo la open ha un nuovo flag di apertura, che e&#x27; O_PATH...<br>con O_PATH non apriamo il file in scrittura o lettura, bensi apriamo un file descriptor in modalita O_PATH e possiamo usarlo per tutto<br><br>chiaramente dentro tutte queste chiamate c&#x27;&#232; una idea comune, ovvero scrivere codice multithread.. dov&#x27;e&#x27; che quindi le chiamate diventato obselete per il codice multithread? (bho, non lo sa manco lui)<br><br><br>se abbiamo dei file aperti e facciamo una fork, entrambi i processi continueranno ad avere quei file aperti<br>con una exec il programma erediter&#224; i file aperti<br><br>fcntl (file control)&nbsp;<br><a href="https&#x3a;&#x2F;&#x2F;man7&#x2e;org&#x2F;linux&#x2F;man&#x2d;pages&#x2F;man2&#x2F;fcntl&#x2e;2&#x2e;html" rel="noreferrer noopener">https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;fcntl.2.html</a><br><br>abbiamo detto che i device vengono visti come file, ma anche se &#232; comodo per fare naming e molto spesso le operazioni che vogliamo fare sono di lettura o scrittura, ci sono molte operazioni che non si possono fare utilizzando solo lettura e scrittura, ma vogliamo dare al device molte altre indicazioni con una propria logica<br>per questo esiste la sys call ioctl (iocontrol)<br><a href="https&#x3a;&#x2F;&#x2F;man7&#x2e;org&#x2F;linux&#x2F;man&#x2d;pages&#x2F;man2&#x2F;ioctl&#x2e;2&#x2e;html" rel="noreferrer noopener">https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;ioctl.2.html</a><br><br>gestione utenti:<br>bisogna dire che un processo ha almeno 3 utenti e 3 gruppi<br>utente reale, effetivo e salvato<br>stessa cosa per i gruppi<br>normalmente questi coincidono<br>utenti e gruppo servono a determinare chi pu&#242; fare cosa<br><em>il comando whoami ti dice chi sei</em><br><br>esistono eseguibili che vengono salvati con il bit setuserid dato dalla &#x27;s&#x27;<br>setuid:&nbsp; <a href="https&#x3a;&#x2F;&#x2F;man7&#x2e;org&#x2F;linux&#x2F;man&#x2d;pages&#x2F;man2&#x2F;setuid&#x2e;2&#x2e;html" rel="noreferrer noopener">https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;setuid.2.html</a><br>quando quest eseguibile viene lanciato da un exec dall&#x27;utente settato, fa in modo che gli effetti siano quelli che avrebbe se venissse chiamato da root<br>getuid ritorna l&#x27;user id effettivo del processo chiamante<br><br># LEZIONE DEL 11&#x2F;11&#x2F;2020 ----------------------------------------------------------------------------------------------------<br><br><strong><u>Programmazione concorrente</u></strong><br><br><strong>*************************************************************notes****************************************************************************</strong><br>Riassunto precedenti puntate:&nbsp;<br>* race condition, necessit&#224; di mutua esclusione&nbsp;<br>* def. azione atomica - cosa &#232; atomico?&nbsp;<br>* assioma finite progress&nbsp;<br>* propriet&#224; di safety e di liveness&nbsp;<br><br>* sezioni critiche&nbsp;<br>* si pu&#242; fare con soluzioni interamente SW? s&#236;, Dekker Peterson&nbsp;<br><br>* CS con istruzioni atomiche del processore: test&amp;set&nbsp;<br>* spinlock&nbsp;<br><br>* Semafori 2op P e V -- : invariante nP &lt;= init + nV. 0 &lt;= {nV + init - nP}&nbsp;<br>* Semafori fair&#x2F;fifo&nbsp;<br>* CS con semafori&nbsp;<br>semaphore mutex(1)&nbsp;<br>&nbsp; csenter-&gt;mutex.P()&nbsp;<br>&nbsp; csexit-&gt;mutex.V()&nbsp;<br>&nbsp;<br>* Implementazione dei semafori in sistemi monoprocessore e multiprocessore&nbsp;<br><br>* problemi classici:&nbsp;<br>- Produttore-Consumatore&nbsp;<br>- Buffer Limitato&nbsp;<br>- Cena dei Filosofi&nbsp;<br>- Lettori Scrittori<br><br>=======================================================================================&nbsp;<br><br>Semafori Binari: invariante&nbsp;<br>invariante nP &lt;= init + nV. 0 &lt;= {nV + init - nP}, 0 &lt;= {nV + init - nP} &lt;= 1<br><br><em>Si possono implementare Semafori Binari con Semafori?</em> S&#236;&nbsp;<br>class binarysem:&nbsp;<br>&nbsp; private semaphore S0, S1&nbsp;<br>&nbsp; public binarysem(v): S0(v), S1(1-v)&nbsp;<br>&nbsp; public binaryP(): S0.P(), S1.V()&nbsp;<br>&nbsp; public binaryV(): S1.P(), S0.V()<br>&nbsp;&nbsp;<br><em>Si possono implementare Semafori con Semafori Binari?</em> S&#236;<br>class semaphore:&nbsp;<br>&nbsp; binarysem mutex(1)&nbsp;<br>&nbsp; binarysem blocked(0)&nbsp;<br>&nbsp; int value;&nbsp;<br>&nbsp; int waiting = 0;&nbsp;<br>&nbsp; public init(v): mutex.bP(); value=v; mutex.bV();&nbsp;&nbsp;<br>&nbsp; public P(): mutex.bP();&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if value == 0:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; waiting++;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mutex.bV()&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; blocked.bP()&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value--&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mutex.bV()&nbsp;<br>&nbsp; public V(): mutex.bP();&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if waiting &gt; 0:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; waiting--&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; blocked.bV()&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value++&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mutex.bV();&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><ul class="indent"><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mutex blocked value waiting&nbsp;</ul>S(0) -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;<br>a:S.P()-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;<br>c:S.V()-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><br>mutex.P() ---- sem.P() BLOCCANTE ---- mutex.V()&nbsp;<br><br>Potere espressivo dei paradigmi di programmazione concorrente&nbsp;<br><br>Lettori e scrittori con passaggio del testimone&nbsp;<br><br>Difetti dei semafori&nbsp;<br><br>MONITOR&nbsp;<br>variabili di condizione: wait signal&nbsp;<br>entry Q, wait Qs, urgent stack&nbsp;<br>politica signal urgent&nbsp;<br><br>Mutua esclusione con monitor&nbsp;<br>Implementazione semafori con monitor&nbsp;<br>Implementazione monitor con semafori&nbsp;<br><br>Problemi campione: PC BB&nbsp;<br><br><strong>************************************************************************************************************************************************</strong><br><br>Deadlock: pi&#249; processi si pongono in attesa uno con l&#x27;altro in modo che non ci possa pi&#249; essere evloluzione (ognuno necessita di qualcosa che ha un altro processo)<br>Starvation: qualche processo non pu&#242; avanzare perch&#232; altri processi &quot;rubano&quot; la possibilit&#224; di avanzare (es. sistemi con priorit&#224;)<br><br>Semaforo:&nbsp;<br>&nbsp;&nbsp;&nbsp; abbiamo&nbsp; visto l&#x27;esempio con due operazioni<br>&nbsp;&nbsp;&nbsp; e un invariante: nP &lt;= init + nV. 0 &lt;= {nV + init -nP}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dove quello tra graffe si chiama valore del semaforo<br>&nbsp;&nbsp;&nbsp; Il semaforo con solo l&#x27;invariante per&#242; non ci dir&#224; quale dei processi bloccati andr&#224; avanti<br><br>Semaforo fair&#x2F;fifo rispetta l&#x27;ordine in cui si ha accesso&nbsp; &#x27;alle risorse&#x27;<br><ul class="indent"><li>prendiamo dei processi chiamati&nbsp; a b c d</li><li>s init 0</li><li>a: s.P()</li><li>pu&#242; continuare o deve aspettare? deve aspettare</li><li>b: s.P()</li><li>c: x.P()</li><li>Aspettano tutti</li><li>d: x.V()</li><li>fifo in questo caso fa in modo che venga riattivato il primo che si &#232; messo in attesa (a)</ul><br><br>Gestione della CS con semaforo<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; semaphore mutex(1)<br><ul class="indent"><li>&nbsp;&nbsp;&nbsp; csenter-&gt;mutex.P()<ul class="indent"><li>csexit-&gt;mutex.V()</ul></li></ul><br>Tutti i semafori sono FIFO almeno che non c&#x27;e&#x27; scritto diversamente<br><br>esemio di spinlock fatto con test and set<br><ul class="indent"><li>TS(x,y) &lt;x = y ; y = 1&gt;</li><li>lo spinlock funziona in questo modo: esiste una variabile locale che inizialmete &#232; a 0</li><li>con 0: CS libera</li><li>1: CS occupata</li><li>CSENTER:</li><li>&nbsp;do<ul class="indent"><li>TS(local,Global)</ul><li>while(l==1)</li><li>CSEXIT:</li><li>G=0<ul class="indent"></ul><li>Se vi sono piu processi che vogliono entrare, fa la TS e copia il valore di G in l</li><li>variabile globale =&gt; y</li><li>TS assegna a L il valore di G</li><li>tutti gli altri processi che vogliono entrare nella CS si mettono a ciclare finch&#232; il processo che aveva preso la SC per primo la lascia e mette G a 0. Cosi la prossima TS mettera il suo l = 0 e potr&#224; entrare.</ul><br>questo soddisfa 3 delle condizioni delle critical section:<br>&nbsp;&nbsp;&nbsp; 1) mancanza di attese non necessarie<br>&nbsp;&nbsp;&nbsp; 2) no deadlock<br>&nbsp;&nbsp;&nbsp; 3) mutua esclusione<br><br>Non soddisfa la condizione &quot;no starvation&quot;<br><ul class="indent"><li><ul class="indent"><li><ul class="indent"></ul></li></ul></li></ul>Spinlock pu&#242; presentare starvation se un processo &#232; sfigato e gli altri processi gli rubano sempre la critical section prima<br>Abbiamo visto alcuni esempi classici di programmazione concorrente<br><br>SEMAFORO BINARIO<br>semaforo che pu&#242; assumere solamente i valori 0 e 1<br>invariante: 0 &lt;= {nV + init - nP} &lt;= 1<br><br>noi possiamo implementare sti semafori binari con i semafori normali<br>Implementazione elegante (nel sistema considerato ho gi&#224; i semafori &quot;normali&quot;):<br>class binarysem:<br><ul class="indent"><li>private&nbsp; semaphore S0, S1 &#x2F;&#x2F;per implementare i semafori binari usiamo due semafori normali</li><li>public binarysem(v):&nbsp; S0(v),&nbsp; S1(1-v); &#x2F;&#x2F;Inizializzati con valori diversi</li><li>public binaryP(): S0.P(), S1.V() &#x2F;&#x2F;implementazione</li><li>public binaryV(); S1.P(), S0.V()&nbsp;&nbsp; &#x2F;&#x2F;sono due s()emafori che operano al contrario</li><li>Simulazione del funzionamento:</li><li>bS = 0 =&gt; S0 = 0, S1 = 1</li><li>a:bS.V() -&gt; S0 = 1, S1 = 0</li><li>c:bS.V() -&gt; bloccato su S1.P()</li><li>d:bS.P() -&gt; S0 = 0, S1 = 1</li><li>. . . c:bS.V() -&gt; S0 = 1, S1 = 0</li><li>a.bS.P() -&gt; S0 = 0, S1 = 1</li><li>d:bS.P() -&gt; bloccato su S0.P()</ul><br>Si possono implementare i semafori con i semafori binari?<br>class semaphore():<br><ul class="indent"><li>binarysem mutex(1) &#x2F;&#x2F;questo serve per fare mutua esclusione, serve per lavorare sulle variabili pubbliche &#x2F;&#x2F;senno race condition</li><li>binarysem blocked(0)</li><li>int value&nbsp;</li><li>int waiting = 0&nbsp;</li><li>public init(v): mutex.bP(); value = v; mutex.bV()</li><li>public P(): mutex.bP();<ul class="indent"><li><ul class="indent"><li><ul class="indent"><li>if value == 0: waiting++; mutex.bV(); blocked.P()<ul class="indent"><li>else value--<ul class="indent"><li>mutex.bV();</ul></li></ul></li></ul></li></ul></li></ul><li>public V():mutex.bP(); &#x2F;&#x2F;se ci sono processi bloccati. sblocca il primo<ul class="indent"><li><ul class="indent"><li><ul class="indent"><li>if waiting &gt; 0:&nbsp; <em>waiting--</em>; blocked.V()<ul class="indent"><li>else value++ &#x2F;&#x2F;altrimenti incrementa il valore del semaforo</ul><li>mutex.bV();</li><li>mutex&nbsp;&nbsp;&nbsp; blocked&nbsp;&nbsp; value&nbsp;&nbsp; waiting</ul></li></ul></li></ul></li></ul>S(0)-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>a:S.P()-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#x2F;&#x2F;x serve per dire che si blocca li, infatti c&#x27;&#232; un deadlock&nbsp;<br>c:S.V() -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><br><br>NON BISOGNA MAI FARE UNA P BLOCCANTE IN UNA MUTUA ESCLUSIONE<br><br>Cosi&#x27; infatti non si esce mai dalla mutua esclusione, e tutto cio che dipende da quella mutex infatti viene bloccato -&gt; c &#232; deadlock<br><br>I semafori quando fanno la V non dicono &quot;vai avanti&quot; ma dicono &quot;hai il diritto di andare avanti&quot;<br><br><br>task:<br>&nbsp;&nbsp;&nbsp; .... aspettare la condizione di poter fare l&#x27;operaazione<br>fare l&#x27;operazione<br>riattivare tutti i processi che ora possono andare avanti<br><br>P();&nbsp;<br><ul class="indent"><li>aspetta che value&gt;0</li><li>value--</ul>V();&nbsp;<br><ul class="indent"><li>value++</li><li>se c &#232; una P in attesa bloccala</li><li>possiamo pensare in maniera descrittiva di fare questa cosa, ma queste cose vanno fatte in mutua esclusione</ul><br>il processo che apre la mutex non &#232; necessariamente quello che la termina: passaggio del testimone -&gt; se un processo cambia stato si pu&#242; attivare un altro processo lasciandogli la mutex<br><br>class semaphore():<br><ul class="indent"><li>binarysem mutex(1)&nbsp;</li><li>binarysem blocked(0)</li><li>int value&nbsp;</li><li>int waiting = 0&nbsp;</li><li>public init(v): mutex.bP(); value = v; mutex.bV()</li><li>public P(): mutex.bP();<ul class="indent"><li><ul class="indent"><li><ul class="indent"><li>if value == 0:&nbsp;<ul class="indent"><li>waiting++;&nbsp;</li><li>mutex.bV();&nbsp;</li><li>blocked.P()</li><li>waiting--</ul><li>value--</li><li>mutex.bV();</li></ul></li></ul></li></ul><li>public V():mutex.bP();&nbsp;<ul class="indent"><li><ul class="indent"><li><ul class="indent"><li>value++</li><li>if waiting &gt; 0:&nbsp;&nbsp;<ul class="indent"><li>blocked.V()</ul><li>else&nbsp;<ul class="indent"><li>mutex.bV();</li></ul><li>mutex&nbsp;&nbsp;&nbsp; blocked&nbsp;&nbsp; value&nbsp;&nbsp; waiting</ul></li></ul></li></ul></li></ul>S(0)-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>a:S.P()-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>c:S.V()-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mutex va a 0 e torna a 1 quando a continua<br>a questo punto chiunque fa la P o la V &#232; fuori dai giochi<br>a cont -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br>a:S.P()-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>c:S.P() -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>quindi oltre a che &#232; il primo in coda, si &#232; bloccato anche c<br>d:S.V() -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>a questo punto l&#x27;unico che puo andare avanti &#232; chi viene sbloccato, ma siccome il semaforo &#232; binario ma fifo<br>a cont -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1<br><br>altro es<br>S(0)-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>a:S.P()-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>b:S.V() -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>c:S.V() -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp; &#232; fuori dalla mutex quindi &#x27;non mi rompe le scatole e aspetta&#x27;<br><br>quando io segnalo blocked lo faccio senza rilasciare la mutua esclusione e questo mi da la proprieta fondamentale di dire che se la V sblocca un processo, io riattivo il processo che si era bloccato passandogli la mutua esclusione, mentre se non c e nessun proccesso in attesa rilascio la mutua esclusione.<br><br>la forza del passaggio del testimone sta nel fatto che si attende il cambio di stato e poi si ricomincia dal primo processo che attendeva il cambio di stato<br><br>Anche se il dominio dei valori appare diverso, i programmi che si possono scrivere con i semafori binari e normali sono gli stessi<br><br>&#x2F;&#x2F;Possiamo riscrivere i semafori in questo modo<br><br>&lt; ASPETTA&nbsp; cond_i -&gt; azione_i &gt;<br>&lt; azione_j&gt;<br><br>P-&gt; &lt; ASPETTA value &gt; 0 -&gt; value-- &gt;<br>V-&gt; &lt; value++ &gt;<br><br>&lt; ASPETTA&nbsp; cond_i -&gt; azione_i &gt;:<br>&nbsp;&nbsp;&nbsp; mutex.P()<br>&nbsp;&nbsp;&nbsp; if (!cond_i) &#x2F;&#x2F;questo il &#232; una sostituzione a &quot;cervello spento&quot; di ASPETTA cond_i<br><ul class="indent"><li><ul class="indent"><li>contatore_cond_i ++</li><li>mutex.V()</li><li>sem_cond_i.P()</li><li>contatore_cond_i--</ul><li>azione_i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#x2F;&#x2F; qui siamo certi che la condizione sia vera&nbsp;</li><li>NUOVOSTATO()</ul><br>&lt; azione_j&gt;<br><ul class="indent"><li>mutex.P()</li><li>azione_j</li><li>NUOVOSTATO()</li></ul><br>NUOVOSTATO()<br>&#x2F;&#x2F; se qualcuno era bloccato sulla condizione zero gli dai una V, come fa? Guarda la condizione e il suo contatore<br><ul class="indent"><li>if (cond_0 &amp;&amp; contatore_cond(0) &gt; 0) sem_cond_0.V()</li><li>else (cond_1 &amp;&amp; contatore_cond(1) &gt; 0)&nbsp; sem_cond_1.V() &#x2F;&#x2F;same e cos&#236; via</li><li>....</li><li>else<ul class="indent"><li>mutex.V() &#x2F;&#x2F;oppure semplicemente rilasci la mutex ridando il controllo, la fai quando nessuno era in attesa in particolare. Questo &#232; perch&#232; se fosse partito uno degli &quot;if&quot; avveniva il passaggio del testimone l&#x27;altro processo avrebbe poi rifatto la V restituendo la mutex alla fine nel frattempo lui pu&#242; fare tutti i suoi passaggi in tranquillit&#224; perch&#232; la mutex sta a 0 e nessuno pu&#242; interferire.</ul><li>&#x2F;&#x2F;potrei permutare le condizioni e avrebbe tutto ancora senso, potrei quindi cambiare questo if-then-else e&nbsp;</li><li>&#x2F;&#x2F; chiamarlo &quot;if non deterministico&quot;.</li><li>questa funzione (nuovostato) dice: visto che e cambiato lo stato del sistema, quali sono quei processi che grazie a quest cambiamento possono andare avanti?</li><li>questo risolve una grande gamma di problemi, ma non &#232; tutto automatico</li><li>nuovostato nasconde un problema che il programmatore deve risolvere: la numerazione delle condizioni e quale processo mandare avanti se le condizioni sono verificate</li></ul># LEZIONE DEL 13&#x2F;11&#x2F;2020 ----------------------------------------------------------------------------------------------------<br><br>i socket sono implementati nei sistemi operativi come sys call<br><br>Strtok divide una stringa in token dato un delimitatore(nel nostro caso lo spazio)<br><br>losetup fa in modo che &#x2F;dev&#x2F;loop0 sia un device che rappresenta l&#x27;immagine del disco<br><br><strong>pipe</strong>() creates a pipe, a unidirectional data channel that can be used for interprocess communication.&nbsp; The array pipefd is used to return two file descriptors referring&nbsp; to&nbsp; the&nbsp; ends&nbsp; of&nbsp; the&nbsp; pipe.&nbsp;&nbsp; pipefd[0] refers to the read end of the pipe.&nbsp;<br>pipefd[1] refers to the write end of the pipe.&nbsp; Data written to the&nbsp; write&nbsp; end&nbsp; of the&nbsp; pipe is buffered by the kernel until it is read from the read end of the pipe. For further details, see <strong>pipe</strong>(7).<br><br><br>#include&lt;stdio.h&gt;<br>#include&lt;unistd.h&gt;<br><br>int main(argc, char*argv[]){<br><ul class="indent"><li>int pipefd[2];</li><li>pipe(pipefd);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#x2F;&#x2F;crea due file decriptor</li><li>write(pipefd[1], &quot;ciao&quot;, 5); &#x2F;&#x2F;scrivo qui</li><li>char buff[10];</li><li>int rv=read(pipefd[0], buf, 10); &#x2F;&#x2F;leggo da qui</li><li>if(rv&lt;0)<ul class="indent"><li>return 1;</ul><li>printf(&quot;%s\n &quot;, buf);</li></ul>}<br><br>pipe &#232; un tubo, tutto quello che scriviamo nel descrittore 1 lo possiamo poi leggere nel descrittore 0<br>ma che serve? sembra che ti mandi da solo le cose<br>invece ha un senso se uniamo l&#x27;idea che i descrittori vengono ereditati durante una fork<br><br>esperimento sopra:<br>&nbsp;&nbsp;&nbsp; la sys call pipe instanzia i due file desc del vettore passato come argomento<br>&nbsp;&nbsp;&nbsp; viene creata la pipe<br>&nbsp;&nbsp;&nbsp; in pipefd[1] viene inserito &quot;ciao&quot;<br>&nbsp;&nbsp;&nbsp; da pipe[0] viene letto &quot;ciao&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; questa pipe &#232; unidirezionale, se la vogliamo bidirezionale dobbiamo usare socket pair<br><br><br>#include&lt;stdio.h&gt;<br>#include&lt;unistd.h&gt;<br>#define BUFLENGTH 1024<br><br>int main(int argc, char*argv[]){<br><ul class="indent"><li>int pipefd[2];</li><li>pipe(pipefd);&nbsp;</li><li>switch(fork()){<ul class="indent"><li>case 0:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#x2F;&#x2F;figlio</li><li>{<ul class="indent"><li>close(pipefd[1])</li><li>while (( len = read(pipefd[0], buf, BUFLENGTH)) &gt; 0 ){<ul class="indent"><li>write (STDOUT_FILENO, buf, len)</ul><li>}</ul><li>} break;</li><li>default:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#x2F;&#x2F;padre</li><li>{<ul class="indent"><li>close(pipefd[0])</li><li>while (( len = read(pipefd[0], buf, BUFLENGTH)) &gt; 0 ){<ul class="indent"><li>write (pipefd[1], buf, len)</ul><li>}</ul><li>}break;</li><li>case -1: return 1&nbsp;&nbsp;&nbsp;&nbsp; &#x2F;&#x2F;errore</ul><li>}</ul>}<br><br>caso alternativo:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; dup2(pipefd[0],0)<br>&nbsp;&nbsp;&nbsp; close(pipefd[0])<br>&nbsp;&nbsp;&nbsp;&nbsp; close(pipefd[1])<br>&nbsp;&nbsp;&nbsp; inseriamo execlp(&quot;sort&quot;,&quot;sort&quot;,&quot;-r&quot;, NULL) nel figlio e<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; dup2(pipefd[1],1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(pipefd[0])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(pipefd[1])<br>&nbsp;&nbsp;&nbsp;&nbsp; inseriamo execlp(&quot;ls&quot;,&quot;ls&quot;,NULL) nel padre<br><br>questo fa la stessa cosa del programma precedente<br>oggi abbiamo imparato cosa viene fatto a livello di sys call per poter eseguire questa funzionalit&#224;<br><ul class="indent"></ul>questa funziona benissimo come canale di collegamento tra processi parenti, che quindi usano la pipe per parlare<br><br>visto come &#232; stata costruita, la pipe permette di creare questo canale tra file descriptor per poi farlo ereditare a processi successivamente creati con la fork<br><br>come si fa a far parlare tra loro processi non parenti?<br><ul class="indent"><li>L&#x27;idea &#232; dare un nome alla pipe (che prima non era necessario) e il modo classico in unix &#232; attraverso il file system, questa pipe si chiamer&#224; named pipe.</ul><br><strong>Named pipe:&nbsp;</strong> is an extension to the traditional pipe concept on Unix and Unix-like systems, and is one of the methods of inter-process communication (IPC). A traditional pipe is &quot;unnamed&quot; and lasts only as long as the process. A named pipe, however, can last as long as the system is up, beyond the life of the process. It can be deleted if no longer used. Usually a named pipe appears as a file, and generally processes attach to it for IPC.<br><ul class="indent"></ul>Non &#232; necessario chiudere un estremo della pipe per poter comunicare per&#242; potrebbe non essere identificato l&#x27;eof perch&#232; l&#x27;altro processo deve ancora scrivere<br><ul class="indent"></ul>la sys call per creare la named pipe &#232; mknod(s, S_IFIFO | 0666, 0): <a href="https&#x3a;&#x2F;&#x2F;man7&#x2e;org&#x2F;linux&#x2F;man&#x2d;pages&#x2F;man1&#x2F;mknod&#x2e;1&#x2e;html" rel="noreferrer noopener">https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man1&#x2F;mknod.1.html</a><br><br>Chat con due fifo<br>vogliamo che due persone collegate in due terminali possano chattare<br>Quello che viene scritto su un terminale deve comparire nell&#x27;altro e viceversa<br>O scriviamo un programma multithread o A EVENTI<br>Esistono delle syscall (tipo select()) capaci di aspettare eventi da un insieme di descrittori<br>Per farlo servono due pipe, una terminale 1-&gt; terminale 2 e una terminale 2-&gt;terminale 1<br><br>sys call select: <a href="https&#x3a;&#x2F;&#x2F;man7&#x2e;org&#x2F;linux&#x2F;man&#x2d;pages&#x2F;man2&#x2F;select&#x2e;2&#x2e;html" rel="noreferrer noopener">https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;select.2.html</a><br><ul class="indent"><li>serve alla gestione di eventi di vario tipo, es. scrittura, lettura, eccezionali</li><li>vi&nbsp; anche un parametro per il timeout</li><li>il valore di ritorno &#232; il numero di file descriptor rilevati</li><li>***chat0.c***</ul>#include &lt;stdio.h&gt;&nbsp;<br>#include &lt;unistd.h&gt;&nbsp;<br>#include &lt;fcntl.h&gt;&nbsp;<br>#include &lt;stdlib.h&gt;&nbsp;<br>#include &lt;sys&#x2F;types.h&gt;&nbsp;<br>#include &lt;sys&#x2F;stat.h&gt;&nbsp;<br>#include &lt;sys&#x2F;wait.h&gt;&nbsp;<br>#define BUFLENGTH 1024&nbsp;<br><br>int main(int argc, char *argv[]){&nbsp;<br>&nbsp; int fdin = open(argv[2], O_RDONLY | O_NONBLOCK);&nbsp;<br>&nbsp; int fdout = open(argv[1], O_WRONLY);&nbsp;<br>&nbsp; char buf[BUFLENGTH];&nbsp;<br>&nbsp; for(;;){&nbsp;<br>&nbsp;&nbsp;&nbsp; fd_set readset;&nbsp;<br>&nbsp;&nbsp;&nbsp; FD_ZERO(&amp;readset);&nbsp;<br>&nbsp;&nbsp;&nbsp; FD_SET(0, &amp;readset);&nbsp; &#x2F;&#x2F; 0 vuol dire standard input?<br>&nbsp;&nbsp;&nbsp; FD_SET(fdin, &amp;readset);&nbsp;<br>&nbsp;&nbsp;&nbsp; select(fdin+1, &amp;readset, NULL, NULL, NULL);&nbsp;<br>&nbsp;&nbsp;&nbsp; if(FD_ISSET(0, &amp;readset)){&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t len = read(0, buf, BUFLENGTH);&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(len == 0)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write(fdout, buf, len);&nbsp;<br>&nbsp;&nbsp;&nbsp; }&nbsp;<br>&nbsp;&nbsp;&nbsp; if(FD_ISSET(fdin, &amp;readset)){&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t len = read(fdin, buf, BUFLENGTH);&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(len == 0)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write(1, buf, len);&nbsp;<br>&nbsp;&nbsp;&nbsp; }&nbsp;<br>&nbsp; }&nbsp;<br>&nbsp; close(fdin);&nbsp;<br>&nbsp; close(fdout);&nbsp;<br>}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<br>il ciclo &#232; infinito e ogni volta aspettiam sia da 0 che da fdin<br>poi se leggiamo lunghezza &gt;0 vuol dire che &#232; stato inviato qualcosa<br><br>differenza tra mkfifo e mknod<br>mkfifo &#232; un comando<br>mknod &#232; la sys call<br>-&gt; mkfifo chiama mknod&nbsp;<br><br><br>FD_ISSET&nbsp; (file descriptor is set?) significa che il suo statement &#232; acceso -&gt; c&#x27;&#232; un messaggio<br><br>&#x2F;&#x2F;crea insieme di descrittori da cui leggere&nbsp; poi parte la select: il codice si ferma qui in attesa di leggere dall&#x27;interlocutore degli input o dei dati, se scopre che da stdin ci son dati da leggere li legge e li scrive sulla pipe aperta in scrittura, se invece scopre che ci son dati disponibili sulla pipe aperta in lettura li legge e li scrive sul buffer (credo?)<br><br>al posto della select qualche anno dopo in POSIX hanno inventato la poll, che non ha pi&#249; insiemi ma un vettore di strutture:&nbsp;&nbsp;&nbsp; <a href="https&#x3a;&#x2F;&#x2F;man7&#x2e;org&#x2F;linux&#x2F;man&#x2d;pages&#x2F;man2&#x2F;poll&#x2e;2&#x2e;html" rel="noreferrer noopener">https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;poll.2.html</a><br>&#232; molto pi&#249; comodo della select, vediamone l&#x27;implementazione nel codice di prima:<br><br>#include &lt;stdio.h&gt;&nbsp;<br>#include &lt;unistd.h&gt;&nbsp;<br>#include &lt;fcntl.h&gt;&nbsp;<br>#include &lt;stdlib.h&gt;&nbsp;<br>#include &lt;poll.h&gt;<br>#include &lt;sys&#x2F;types.h&gt;&nbsp;<br>#include &lt;sys&#x2F;stat.h&gt;&nbsp;<br>#include &lt;sys&#x2F;wait.h&gt;&nbsp;<br>#define BUFLENGTH 1024&nbsp;<br><br>int main(int argc, char *argv[]){&nbsp;<br>&nbsp; int fdin = open(argv[2], O_RDONLY | O_NONBLOCK);&nbsp;<br>&nbsp; int fdout = open(argv[1], O_WRONLY);&nbsp;<br>&nbsp; struct pollfd pfd[] = {{0, POLLIN | POLLHUP,0}, {fdin,POLLIN | POLLHUP,0}}<br>&nbsp; char buf[BUFLENGTH];&nbsp;<br>&nbsp; for(;;){&nbsp;<br>&nbsp;&nbsp;&nbsp; poll(pfd, sizeof(pfd)&#x2F;sizeof(*pfd),-1 )&nbsp;&nbsp;&nbsp; &#x2F;&#x2F;trucco: espressione fra costanti e aggiungendo elementi nella def<br>&nbsp;&nbsp;&nbsp;&nbsp; if(pfd[0].revents &amp; POLLHUP) return 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#x2F;&#x2F; viene automaticamente cambiata la lunghezza<br>&nbsp;&nbsp;&nbsp;&nbsp; if(pfd[1].revents &amp; POLLHUP) return 0<br>&nbsp;&nbsp;&nbsp; if(pfd[0].revents &amp; POLLIN){&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t len = read(0, buf, BUFLENGTH);&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(len == 0)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write(fdout, buf, len);&nbsp;<br>&nbsp;&nbsp;&nbsp; }&nbsp;<br>&nbsp;&nbsp;&nbsp; if(pfd[1].revents &amp; POLLIN){&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t len = read(fdin, buf, BUFLENGTH);&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(len == 0)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write(1, buf, len);&nbsp;<br>&nbsp;&nbsp;&nbsp; }&nbsp;<br>&nbsp; }&nbsp;<br>&nbsp; close(fdin);&nbsp;<br>&nbsp; close(fdout);&nbsp;<br>}&nbsp;<br>&nbsp;&#x2F;&#x2F;HUP sta per Hang up o &#x27;riagganciare&#x27;<br><br><br><br>Ma che cosa fa un CTRL + C ?<br><br><strong>I SEGNALI</strong><br>un segnale &#232; un evento che avviene in maniera asincrona rispetto l&#x27;esecuzione del programma<br>(solitamente dovuti ad errori dovute a operazioni sbagliate dell utente)<br>mandati dal kernel<br><br>signal:&nbsp;&nbsp;&nbsp; <a href="https&#x3a;&#x2F;&#x2F;man7&#x2e;org&#x2F;linux&#x2F;man&#x2d;pages&#x2F;man7&#x2F;signal&#x2e;7&#x2e;html" rel="noreferrer noopener">https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man7&#x2F;signal.7.html</a><br><br>Azione standard quando avviene un segnale: pu&#242; essere termino il processo corrente, creo un core&nbsp;<br>segnali e relative azioni sono sul manuale linkato sopra<br>I segnali vengono spesso confusi&#x2F;tradotti con eccezioni in quanto sono simili&#x2F;stessa cosa<br><br>Attenzione ai nomi: es: kill non termina un processo e signal non manda un segnale<br>signal definisce il gestore del segnale<br><br>come si gestiscono i segnali?<br>esempio: programma che non termina con Ctrl + c<br><br><br>#include &lt;stdio.h&gt;<br>#include&lt;signal.h&gt;<br><br>tyedef void strlc_handler(int signo){<br>&nbsp;&nbsp;&nbsp; printf(&quot;PRRR \n&quot;)&nbsp;<br>&nbsp;&nbsp;&nbsp; }<br><br>int main(int argc, char *argv[]){&nbsp;<br>&nbsp;&nbsp;&nbsp; int c;<br>&nbsp;&nbsp;&nbsp; signal(SIGINT, strlc_handler)<br>&nbsp;&nbsp;&nbsp; while ((c=getchar()) != EOF){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putchar(c);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;<br>&#x2F;&#x2F; si puo sempre chiudere con ctrl + d<br><br>commenti:<br>&nbsp;&nbsp;&nbsp; voglio mettere un gestore al control c<br>&nbsp;&nbsp;&nbsp; voglio che avvenga un segnale specifico venga chiamato call handler<br><br># LEZIONE DEL 18&#x2F;11&#x2F;2020 ----------------------------------------------------------------------------------------------------<br><br>==RIASSSUNTO==<br>I semafori sono un&#x27;astrazione creata per facilitare la scrittura dei programmi concorrenti a livello di processi utente.<br><br>Il costrutto ha due parametri P e V che servono a fare sincronizzazione e mutua esclusione (un semaforo inizializzato a 1 e poi si usano P e V per creare e rilasciare mutex)<br><br>*abbiamo visto i problemi classici*<br><br>Potere espressivo dei paradigmi di prog. concorrente (si possono confrontare e creare relazioni di ordine<br><br>es.<br>Semafori vs X -&gt; i semafori sono pi&#249;, meno o ugualmente espressivi rispetto a X?<br>Se riusciamo a implementare i semafori con X (usando le dovute librerie) allora i semafori sono almeno espressivi quanto X (e viceversa).<br>Per avere una relazione d&#x27;ordine questa propriet&#224; deve valere in tutti e due i sensi<br><br>*esempio con semafori binari (invariante -&gt;&nbsp; <strong>0 &lt;= {nV + init - nP} &lt;= 1</strong>)*<br><br>Si possono implementare Semafori Binari con Semafori? Si<br>Si possono implementare Semafori con Semafori Binari? Si<br>Allora hanno lo stesso potere espressivo<br><br>Abbiamo pensto: possiamo pensare a tanti problemi concorrenti come un insieme di funzioni che consentono di cambiare lo stato interno di un problema, il problema &#232; gestito da piu problemi e quindi lo stato &#232; un problema di variabili condivise -&gt; ci sono mutua esclusione etc.. RIGA 2669<br>Possiamo pensare di definire il problema come: date delle azioni che modificano lo stato del Programma&nbsp;<br>Ad ogni cambiamento di stato occorre poi varificare se c&#x27;&#232; qualcuno che sta aspettando lo stato variato, e nel caso fare in modo che questo possa proseguire<br><br><a href="http&#x3a;&#x2F;&#x2F;so&#x2e;v2&#x2e;cs&#x2e;unibo&#x2e;it&#x2F;wiki&#x2F;index&#x2e;php&#x3f;title&#x3d;Decalogo&#x5f;di&#x5f;Programmazione&#x5f;Concorrente" rel="noreferrer noopener">http:&#x2F;&#x2F;so.v2.cs.unibo.it&#x2F;wiki&#x2F;index.php?title=Decalogo_di_Programmazione_Concorrente</a><br><br>==FINE RIASSUNTO==<br><br>Lettori e scrittori con passaggio del testimone (per il passaggio del testimone vedere scorsa lezione, mentre lettore e scrittore li abbiamo visti qualche lezione fa)<br><br>Lettori e scrittori non si possono mettee insieme (o uno scrittore o tanti lettori)<br><br>LEGENDA<br>ww: waiting writers<br>wr: waiting readers<br>nw: numero writers<br>nr: numero readers<br>sr: semaforo lettori<br>sw: semaforo scrittori<br><br>processo Reader:<br>&nbsp;&nbsp;&nbsp; while(1)<br><ul class="indent"><li><ul class="indent"><li>startread()</li><li>read()</li><li>endread()</ul></li></ul><br>process Writer:<br>&nbsp;&nbsp;&nbsp; while (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; startwrite()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endwrite()<br><br>====<br>nr=nw=0<br>startread() -&gt; &lt;ASPETTA nw==0 -&gt; nr++&gt;<br>endread()-&gt; &lt;nr--&gt;<br>&nbsp;startwrite() -&gt; &lt;ASPETTA nr==0 &amp;&amp; nw==0 -&gt; nw++&gt;<br>endwrite() -&gt; &lt;nw--&gt;<br><br>nr=nw=0<br>wr=ww=0<br><br>sem sr(0), sw(0), mutex(1)<br>startread:<br>&nbsp;&nbsp;&nbsp; mutex.P()<br>&nbsp;&nbsp;&nbsp; if(!nw==0):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wr++; mutex,V(); sr.P(); wr--;<br>&nbsp;&nbsp;&nbsp; nr++<br>CAMBIO STATO<br>endread:<br>&nbsp;&nbsp;&nbsp; mutex.P()<br>&nbsp;&nbsp;&nbsp; nr--<br>CAMBIO STATO<br>startwrite:<br>&nbsp;&nbsp;&nbsp; mutex.P()<br>&nbsp;&nbsp;&nbsp; if(!nw==0 &amp;&amp; nw==0):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ww++; mutex.V(); sw.P(); ww--<br>&nbsp;&nbsp;&nbsp; nw++<br>CAMBIO STATO<br>endwrite:<br>&nbsp;&nbsp;&nbsp; mutex.P()<br>&nbsp;&nbsp;&nbsp; nw--<br>CAMBIO STATO &#x2F;&#x2F;Qui c&#x27;&#232; starvation: se continuano ad arrivare lettori<br>if (nw==0 &amp;&amp; nr&gt;0) sr.V()<br>else if ((nr==0 &amp;&amp; nw==0) &amp;&amp; ww&gt;0) sw.V()<br>else mutex.V()<br><br>startread:<br>&nbsp;&nbsp;&nbsp; mutex.P()<br>&nbsp;&nbsp;&nbsp; if(nw!=0):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wr++; mutex,V(); sr.P(); wr--;<br>&nbsp;&nbsp;&nbsp; nr++<br>&nbsp;&nbsp;&nbsp; if(nw &gt; 0) sr.V() else mutex.V()<br>endread:<br><ul class="indent"><li>mutex.P()</li><li>nr--</li><li>if(wr &gt; 0) sr.V()</li><li>elseif(nr == 0 &amp;&amp; ww &gt;0) sw.V()</li><li>else mutex.V()</ul>startwrite:<br>&nbsp;&nbsp;&nbsp; mutex.P()<br>&nbsp;&nbsp;&nbsp; if( !(nr==0 &amp;&amp; nw==0) ):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ww++; mutex.V(); sw.P(); ww--<br>&nbsp;&nbsp;&nbsp; nw++<br>&nbsp;&nbsp;&nbsp; mutex.V()<br>endwrite:<br><ul class="indent"><li>mutex.P()</li><li>nw--</li><li>if(ww&gt; 0) sw.V()</li><li>elseif(wr &gt; 0) sr.V()</li><li>else mutex.V()</ul><br>Abbiamo peggiorato la situazione<br>mettiamo che arrivano lettori uno dopo l&#x27;altro e intanto se ne va sempre uno: gli scrittori non entrano mai<br>stessa cosa gli scrittori, si mandano avanti a vicenda<br>La soluzione &#232; fare a turni: uno scrittore, poi tutti i lettori in attesa, poi un altro scrittore, e cos&#236; via<br><br>startread:<br><ul class="indent"><li>mutex.P()</li><li>if(nw &gt; 0 || ww &gt; 0):<ul class="indent"><li>wr++; mutex,V(); sr.P(); wr--;</ul><li>nr++</li><li>if(wr &gt; 0) sr.V() else mutex.V()</ul>endread:<br><ul class="indent"><li>mutex.P()</li><li>nr--</li><li>if(nr == 0 &amp;&amp; ww &gt;0) sw.V()</li><li>else mutex.V()</ul>startwrite:<br><ul class="indent"><li>mutex.P()</li><li>if( !(nr==0 &amp;&amp; nw==0) ):<ul class="indent"><li>ww++; mutex.V(); sw.P(); ww--</ul><li>nw++</li><li>mutex.V()</ul>endwrite:<br><ul class="indent"><li>mutex.P()</li><li>nw--</li><li>if(wr&gt; 0) sr.V() &#x2F;&#x2F;con questa V risveglio tutti i lettori in attesa</li><li>elseif(ww&gt; 0) sw.V()</li><li>else mutex.V()</ul><br>Abbiamo cosi risolto il problema di lettori e scrittori senza starvation<br><br><br><strong>Difetti dei semafori</strong><br>Siamo riusciti a scrivere i problemi campione...ma<br>ad esempio abbiamo poca leggibilit&#224; nei semafori, sembra un po la programmazione con i goto.<br>Due passi in avanti:<br>&nbsp;&nbsp;&nbsp; programmazione strutturata<br><br>MONITOR<br>Immaginiamo i monitor come una classe con attributi privati o protetti.<br>Per acccedere a questi attributi dobbiamo usare dei metodi<br><br>PRIMA ISTANZA:<br>monitor contocorrente:<br>&nbsp;&nbsp;&nbsp; saldo = 0<br>&nbsp;&nbsp;&nbsp; entry versamento (x): saldo +=x<br>&nbsp;&nbsp;&nbsp; entry prelievo (x): saldo-=x<br><br>Il monitor implementa gi&#224; una critical section: al suo interno pu&#242; esserci max 1 processo in esecuzione<br><br>variabili di condizione: metodi wait e signal<br>c.wait aspetta la condizione c (sempre bloccante)<br>c.signal: il primo che sta aspettando la condizione pu&#242; andare avanti (guarda che la condizione c &#232; verificata<br>condition c<br><br>Problemi:<br>se pi&#249; processi aspettano la stessa condizione?<br><ul class="indent"><li>La signal risveglia il primo (FIFOness)&nbsp;</ul>Se il processo A chiama una funzione del monitor che cambia lo stato rendendo la condizione C vera e fa c.signal, cosa deve fare signal per non avere due processi che avanzano insieme?<br><ul class="indent"><li>signal urgent -&gt; quando arriva c.signal due casi:</ul><ul class="bullet"><li><ul class="bullet"><li>nessuno sta aspettando quella condizione -&gt; la signal viene persa</li><li>c&#x27;&#232; almeno un processo che attende la connessione e viene attivato il primo (per&#242; sospendendo il processo che ha fatto la signal)</ul></li></ul>quando un processo in attesa si attiva o aspetta un altra condizione o inizia ad eseguire sul monitor<br><br><br>Ascii art (il monitor &#232; uno solo)<br><ul class="indent"><li><ul class="indent"><li><ul class="indent"><li><ul class="indent"><li><ul class="indent"><li><ul class="indent"><li><ul class="indent"><li><ul class="indent"></ul></li></ul></li></ul></li></ul><li>&nbsp; URGENT STACK&nbsp;<ul class="indent"><li>&nbsp; |_|_|_|_|_|<ul class="indent"><li><ul class="indent"><li>&#8613;</ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>CODA DI INPUT --&gt; |MONITOR| &#8644; variabili di condizione<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |_|_|_|_|_|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |MONITOR| &#8644; |_|_|_|_|_|&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |MONITOR| &#8644; |_|_|_|_|_|&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |MONITOR| &#8644; |_|_|_|_|_|&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |MONITOR| &#8644; |_|_|_|_|_|&nbsp;<br><ul class="indent"><li><ul class="indent"><li><ul class="indent"><li><ul class="indent"><li><ul class="indent"><li><ul class="indent"><li><ul class="indent"><li>&#8615;</ul><li>&nbsp;&nbsp;&nbsp; &#x2F;&#x2F;&#x2F;</ul></li></ul></li></ul></li></ul></li></ul></li></ul>enqueue: invocazione di procedure entry -&gt; c.wait()<br>dequeue: il monitor &#232; vuoto; urgent stack &#232; vuoto -&gt; c.signal()<br><br>implementiamo i semafori con un monitor:<br><br>monitor semaphore:<br><ul class="indent"><li>int value</li><li>condition ok2p &#x2F;&#x2F; condizione: value &gt; 0</li><li>def semaphore(x):<ul class="indent"><li>value = X</ul><li>entry P()<ul class="indent"><li>if(! ( value &gt; 0) ):<ul class="indent"><li>ok2p.wait()</li><li>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; in questo punto ho la certezza che ok2p &#232; vera</ul><li>value--</ul><li>entry V()<ul class="indent"><li>value ++</li><li>ok2p.signal()</ul></li></ul><br>non abbiamo bisogno di mutua esclusione perch&#232; il monitor di per se la garantisce<br><br>semaphore mutex(1)<br><br>value = 1<br>&#x2F;&#x2F;A,B,C processi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; il tempo fluisce verso il basso<br>A mutex.P() -&gt; value-- e prende la mutua esclusione<br>B mutex.P() -&gt; B si ferma nello statement di ok2p.wait()<br>C mutex.P() -&gt; C fa esattamente come B<br><br>A mutex.V()&nbsp; -&gt; value++,&nbsp; ok2p.signal() -&gt; A si ferma su questo statement<br>il primo in coda &#232; B<br>B -&gt; value -- e prende la mutua esclusione<br>urgent A -&gt; viene ripristinato A ma era all&#x27;ultimo statement ed esce<br><br>il monitor cosa fa: prima di ammettere altri processi consuma lo stack<br><br><br>In letteratura era stata definita l&#x27;idea di aspettare di far finire il processo che fa signal e poi eseguire quello in attesa ma nel frattempo potrebbero cambiare le carte in tavola e quello in attesa potrebbe nona ver pi&#249; la risorsa =&gt; lo urgent stack &#232; la politica migliore.<br><br><br>&#x2F;&#x2F;num = numero processi nella SAU che per&#242; dovran uscire assieme<br>&#x2F;&#x2F;waiting = numero processi in attesa di risorse<br>monitor SAU<br><ul class="indent"><li>int num = 0</li><li>waiting = 0</li><li>condition ok2exit&nbsp;&nbsp;&nbsp;&nbsp; &#x2F;&#x2F; num == waiting</li><li>entry enter:<ul class="indent"><li>num++</ul><li>entry exit:<ul class="indent"><li>waiting++</li><li>if(num &gt; waiting)<ul class="indent"><li>ok2exit.wait()</ul><li>waiting--</li><li>num--</li><li>ok2exit.signal()</ul></li></ul><br><br>num 0<br>waiting 0<br>A enter...exit<br><br>------------------------------<br><br>num 0<br>waiting 0<br>A enter -&gt;&nbsp; num++<br>B enter -&gt; num++<br>C enter -&gt; num++<br><br>B exit -&gt; waiting++<br>A exit -&gt; waiting++<br><br>D enter -&gt; num++<br>D exit -&gt; waiting++<br><br>ok2exit B A D&nbsp;<br><br>C exit -&gt; waiting ++&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#x2F;&#x2F;diventa 4, che &#232; uguale a num<br><ul class="indent"><li>-&gt; c va nello urgent stack</li><li>-&gt; b esce dallo urgent stack&nbsp;</ul><br><br><br>problema di lettori e scrittori con i monitor:&nbsp;&nbsp; VERSIONE SENZA STARVATION<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; monitor rw:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nr=nw=0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ww=0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; condition ok2read&nbsp; &#x2F;&#x2F;&nbsp; nw==0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; condition ok2write &#x2F;&#x2F; nw==0 &amp;&amp; nr ==0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; startread:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( nw&gt;0 || ww &gt; 0 ) ok2read.wait()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nr++<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ok2read.signal()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endread<br><ul class="indent"><li><ul class="indent"><li>&nbsp;nr--</li><li>&nbsp;ok2read.signal()</li><li>if ( nr==0 ) ok2write.signal()</ul></li></ul>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; startwrite<br><ul class="indent"><li><ul class="indent"><li>if ( !(nw==0 &amp;&amp; nr ==0) ) ww++; ok2write.wait(); ww--</li><li>nw++</li><li>&nbsp;if ( nw==0 ) ok2read.signal()</li><li>&nbsp;if ( nw==0 &amp;&amp; nr==0 ) ok2write.signal()</ul></li></ul>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endwrite<br><ul class="indent"><li><ul class="indent"><li>nw--</li><li>ok2read.signal()</li><li>&nbsp;if (&nbsp; nr==0 ) ok2write.signal()</ul></li></ul><br># LEZIONE DEL 20&#x2F;11&#x2F;2020 ----------------------------------------------------------------------------------------------------<br><br>Descrittori: (ripasso)<br>&nbsp;&nbsp;&nbsp; 0 std input<br>&nbsp;&nbsp;&nbsp; 1 std output<br>&nbsp;&nbsp;&nbsp; 2 std error<br><br>Dup2(old,new): chiudi new e fallo diventare un clone di old&nbsp;<br><ul class="bullet"><li>Dup2(pipe[0],1) far&#224; si che quando qualcosa cercer&#224; di accedere a STDOUT(1) non scriver&#224; su STDOUT ma su pipe [0]</ul>Il processo 0 avr&#224; lo stdi nel lato di lettura della pipe, il processo 1 avr&#224; lo stdi nel lato di input della pipe<br>exec esegue i codici di sort e ls, ls vorra scrivere ma inconsciamente non scriver&#224; pi&#249; sul terminale ma scriver&#224; in pipefd[1], anche sort vorr&#224; leggere dei dati e li legger&#224; da pipefd[0].<br><br>Continuiamo a vedere i segnali<br>=RIPASSO=<br>L&#x27;uso dei segnali avviene attraverso syscall dai nomi poco significativi:<br>&nbsp;&nbsp;&nbsp; signal -&gt; definisce cosa fare quando arriva un segnale:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I segnali sono tanti e possono avere degli effetti correlati (es. causare terminazione o bloccare un processo)<br><ul class="indent"><li><ul class="indent"><li>Kill non serve (solo) per uccidere un processo -&gt; si pu&#242; usare per inviare altri segnali</ul></li></ul><br>Dubbi: cosa succede se mentre gestisco un segnale arriva un altro segnale? e se sto eseguendo una syscall? cosa succede ai segnali e ai gestori se faccio fork o exec?<br>I primi segnali di UNIX oggi sono detti inaffidabili perch&#232; non garantivano che tutti i segnali fossero catturati<br>Oggi esistono interfacce molto pi&#249; dettagliate e migliorate in modo che durante la gestione non ci siano problemi di nidificazione di chiamata.<br><br>sigaction (int signum, const struct sigaction *act, struct sigaction *oldact):<br>&nbsp;&nbsp;&nbsp; <a href="https&#x3a;&#x2F;&#x2F;www&#x2e;man7&#x2e;org&#x2F;linux&#x2F;man&#x2d;pages&#x2F;man2&#x2F;sigaction&#x2e;2&#x2e;html" rel="noreferrer noopener">https:&#x2F;&#x2F;www.man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;sigaction.2.html</a><br><ul class="indent"><li>breve desc: serve a fare in modo che la stessa chiamata serva a settare quali azioni fare salvando quelle precedenti (in modo atomico)</li><li>come la signal ma la sigaction permette di avere un azione</ul><br>siginfo -&gt; passato a sigaction<br><ul class="indent"><li>ci fornisce varie informazioni utili sul segnale (es. chi l&#x27;ha mandato)</ul><br>sigset_t -&gt; &#232; una maschera<br><ul class="indent"><li><ul class="indent"></ul></li></ul>static void strlc_handler(int signo)<br>{<br>&nbsp;&nbsp;&nbsp; printf(&quot;PRRR \n&quot;)&nbsp;<br>}<br>int main(int argc, char *argv[]) &#x2F;&#x2F;Fa la stessa cosa di noctrlc ma con sigaction<br>{&nbsp;<br>&nbsp;&nbsp;&nbsp; int c;<br>&nbsp;&nbsp;&nbsp; static struct sigaction act ;<br>&nbsp;&nbsp;&nbsp; act .sa_handler=strlc_handler<br>&nbsp;&nbsp;&nbsp; act.sa_flags = SA_RESTART;<br>&nbsp;&nbsp;&nbsp; sigemptyset(&amp;act.sa_mask);<br>&nbsp;&nbsp;&nbsp; sigaction(SIGNINT, &amp;act, NULL)&nbsp;&nbsp; &#x2F;&#x2F; null serve a settare la new action senza tenere traccia di com era prima&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; while ((c=getchar()) != EOF)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putchar(c);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>}<br>questo codice potrebbe generare un errore dovuto alla libreria C, implementando tutto con le sys call il problema si risolve<br><br>la maschera da informazioni sul segnale&nbsp;<br><br>Che si fa con le maschere? e che ambia tra emptyset e fillset? boh x2<br><br><br>come si possono presentari gli insiemi?<br>(in particolare ci interessano insiemi di segnali)<br>si puo raprresentare la funzione caratteristica dell&#x27;insieme, se devo fare un insieme su abc, posso rappresentarlo attraverso una funzione booleana<br><br>a b c d&nbsp;<br>1 1&nbsp; 0 0&nbsp;<br><br>al posto di abcd avremo dei segnali e verr&#224; assegnato un bit ad ognuno di questi.&nbsp;<br>Signemptyset sar&#224; l&#x27;insieme vuoto di segnali<br>Signfillset definisce l&#x27;insieme universo dei segnali che li contiene tutti,&nbsp;<br>poi possiamo accenderne qualcuno, inserire, togliere, etc<br><br>esempio<br>#include &lt;signal.h&gt;<br>#include &lt;stdio.h&gt;<br><br>void printsigset(sigset_t *set) {<br>&nbsp;&nbsp;&nbsp; int i;<br>&nbsp;&nbsp;&nbsp; for(i=0; i&lt;32; i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;%d&quot;, sigismember(i,set));<br>&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;\n&quot;)<br>&nbsp;&nbsp;&nbsp; }<br><br>int main (int argc, char* argv[]){<br><ul class="indent"><li>sigset_t se, sf;</li><li>sigemptyset(&amp;se);</li><li>printsigset(&amp;se)</li><li>sigfillset(&amp;sf)</li><li>printsigset(&amp;sf)</ul>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; dove&nbsp;<br>&nbsp;&nbsp;&nbsp; sf :full<br>&nbsp;&nbsp;&nbsp; se: empty<br><br>un esempio ulteriore consiste nel copiare la funzione printsigset nel codice precedente<br>definire nell handler un sigset_t di nome current<br>aggiungiamo sigpromask(SIG_BLOCK, NULL, &amp;current)<br>e printsigset(&amp;current)<br><br>ora nel gestore stampo la maschera dei segnali attivi e non attivi<br>cambiando sigemptyset con sigfillset notiamo come cambi l&#x27;insieme<br><br><br>sys call pause<br><ul class="indent"><li>Si ferma e attenda &#236;&#236;e un segnale qualsiasi</li><li><a href="https&#x3a;&#x2F;&#x2F;www&#x2e;man7&#x2e;org&#x2F;linux&#x2F;man&#x2d;pages&#x2F;man2&#x2F;pause&#x2e;2&#x2e;html" rel="noreferrer noopener">https:&#x2F;&#x2F;www.man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;pause.2.html</a></li></ul>equivalente pi&#249; raffinato: sigsuspend<br><ul class="indent"><li>Dice: adesso mi fermo e aspetto uno dei seguenti segnali</li><li><a href="https&#x3a;&#x2F;&#x2F;www&#x2e;man7&#x2e;org&#x2F;linux&#x2F;man&#x2d;pages&#x2F;man2&#x2F;sigsuspend&#x2e;2&#x2e;html" rel="noreferrer noopener">https:&#x2F;&#x2F;www.man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;sigsuspend.2.html</a><ul class="indent"></ul></li></ul>Compito di qualche anno fa: crea un processo che quando riceve un segnale uccide chi glielo ha mandato<br><br>perma.c<br><br>static void handler(int signo, signinfo_t *info, void*arg)<br>{<br>&nbsp;&nbsp;&nbsp; printf(&quot;received %d from %d\n&quot;,signo, info-&gt;si_pid)&nbsp;<br>&nbsp;&nbsp;&nbsp; kill(info-&gt;si_pid, SIGKILL)<br>}<br>int main(int argc, char *argv[]) &#x2F;&#x2F;Fa la stessa cosa di noctrlc ma con sigaction<br>{&nbsp;<br>&nbsp;&nbsp;&nbsp; int c;<br>&nbsp;&nbsp;&nbsp; static struct sigaction act ;<br>&nbsp;&nbsp;&nbsp; act.sa_signaction = handler<br>&nbsp;&nbsp;&nbsp; act.sa_flags = SA_RESTART | SA_SIGINFO;<br>&nbsp;&nbsp;&nbsp; sigfillset(&amp;act.sa_mask);<br>&nbsp;&nbsp;&nbsp; int signo;<br>&nbsp;&nbsp;&nbsp; for(signo=0; signo&lt;32; signo++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signaction<br>&nbsp;&nbsp;&nbsp; for(;;)<br><ul class="indent"><li>&nbsp;&nbsp;&nbsp; pause();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</ul>}<br><br>UTENTI E GRUPPI<br>Utente &#x2F; gruppo reale<br>Utente &#x2F; gruppo effettivo<br>Utente &#x2F; gruppo salvato<br><br>solitamente questi tre coincidono con l&#x27;utente che ha lanciato il programma<br><br>Se lancio un programma di un altro utente continuo ad avere accesso SOLO ai miei files<br>Eseguibili setuserid (creabili solo da root o con capability)<br><br>&#x2F;&#x2F;restituisce user id<br>#include &lt;stdio.h&gt;&nbsp;<br>int main (int argc, char*argv[])<br>{<br><ul class="indent"><li>printf(&quot;%d %d\n&quot;, getuid(), geteuid())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li><li>printf(&quot;%d %d\n&quot;, getuid(), getegid())&nbsp; &#x2F;&#x2F;stampo reali e effettivi all apertura</li><li>uid_e effective = geteuid();</li><li>seteuid(getuid())</li><li>printf(&quot;%d %d\n&quot;, getuid(), geteuid())</li><li>&#x2F;&#x2F;accedo al file</li><li>seteuid(effective)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#x2F;&#x2F;riporto l&#x27;effettivo a quello che mi ero salvato</li><li>printf(&quot;%d %d\n&quot;, getuid(), geteuid())</ul>}<br><br>Con una serie di comandi root si accede ad altri utenti e altri gruppi cambiando il proprio utente effettivo<br><br>esistono anche chiamate pi&#249; moderne (non standard) che ci fanno leggere reale, effettivo e salvato (o settarli) ovviamente con limitazioni dovute ai permessi<br><br>syscall getgroups()<br><ul class="indent"><li>per far sapere ad un utente a che gruppo appartiene&nbsp;</li><li><a href="https&#x3a;&#x2F;&#x2F;www&#x2e;man7&#x2e;org&#x2F;linux&#x2F;man&#x2d;pages&#x2F;man2&#x2F;getgroups&#x2e;2&#x2e;html" rel="noreferrer noopener">https:&#x2F;&#x2F;www.man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;getgroups.2.html</a></ul><br>vogliamo vedere i gruppi di cui facciamo parte:<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;&nbsp;<br>&nbsp;&nbsp;&nbsp; #include &lt;gr.h&gt;<br>int main (int argc, char*argv[])<br>{<br><ul class="indent"><li>int size = getgroups(0, NULL);</li><li>gid_t gid_list[size]</li><li>getgroups(size, gid_list)</li><li>int i</li><li>for(i=0;i&lt;size;i++){<ul class="indent"><li>struct group +g = getgrgid(gid_list[i])</li><li>printf(&quot;%d -&gt; %s\n&quot;, gid_list[i], g-&gt;gr_name)</li></ul><li>}</ul>}<br><br>dove getgrgid: <a href="https&#x3a;&#x2F;&#x2F;linux&#x2e;die&#x2e;net&#x2F;man&#x2F;3&#x2F;getgrgid" rel="noreferrer noopener">https:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;3&#x2F;getgrgid</a><br><br># LEZIONE DEL 25&#x2F;11&#x2F;2020 ----------------------------------------------------------------------------------------------------<br><br>Domande:<br>&nbsp;&nbsp;&nbsp; La urgent stack &#232; fifo? no, essendo uno stack &#232; lifo<br>Link al pizzino: <a href="https&#x3a;&#x2F;&#x2F;etherpad&#x2e;wikimedia&#x2e;org&#x2F;p&#x2F;so2021&#x2e;pizzino" rel="noreferrer noopener">https:&#x2F;&#x2F;etherpad.wikimedia.org&#x2F;p&#x2F;so2021.pizzino</a><br><br>quando un processo fa una signal su una risorsa, il primo nella coda di attesa di quella risorsa rientra nel monitor dalla rispettiva coda di attesa.<br><br>quando il processo esce dal monitor, prima di poter ammettere altri processi nella coda di input, viene preso un processo nello Urgent Stack. Quindi se un processo fa la P ed e&#x27; valore 0, fa una wait.<br><br>waiting e&#x27; un modo per contare i processi bloccati. (e&#x27; sempre bloccante se val == 0)<br><br>la signal ha la peculariata&#x27; che se nessuno sta ascolatando quella condizione, viene persa.<br><br>Il primo esempio del consumer-producer ha buffer di dimensione 1, il secondo dimensione variabile<br><br>La modifica dello stato deve essere fatta completamente nel punto del codice dove avviene la modifica<br><br>Con i monitor i filosofi non danno deadlock perch&#232; rispetto ai semafori nel momento in cui passo al &quot;prendere la seconda bacchetta&quot; non c&#x27;&#232; spazio temporale per gli altri fiolosofi di prendere le rispettive bacchette. Non viene rilasciata la mutua esclusione quindi no deadlock.<br><br>Il problema della seconda versione dei filosofi crea starvation: c&#x27;&#232; la possibilit&#224; che si crei un ciclo infinito in cui 4 non mangia mai<br><br>Il codice di reader-writers senza la coda di attesa degli scrittori ci sarebbe starvation per loro. Se non aggiungessimo l&#x27;ok2read.signal() nella startread() noi risveglieremmo sempre un solo lettore e non tutti quelli in attesa, invece con quella linea di codice avviene l&#x27;entrata &quot;a cascata&quot; di tutti i lettori. Dopo che son entrati tutti se ne voglion entrare altri ma ci son scrittori in attesa devono per forza aspettarli quindi non c&#x27;&#232; starvation per nessuno.<br><br>===PIZZINO===<br>Pizzino della lezione di Sistemi Operativi 25 novembre 2020<br><br>Pizzino della lezione di Sistemi Operativi 25 novembre 2020<br><br>Riassunto precedenti puntate:<br>* Semafori 2op P e V -- : invariante nP &lt;= init + nV.&nbsp; 0&lt;= {nV + init - nP}<br>* Semafori fair&#x2F;fifo<br>* CS con semafori<br><br>* problemi classici con semafori:<br>- Produttore-Consumatore<br>- Buffer Limitato<br>- Cena dei Filosofi<br>- Lettori Scrittori<br><br>Semafori Binari: invariante<br>invariante 0&lt;= {nV + init - nP} &lt;=1<br><br>Potere espressivo dei paradigmi di prog. concorrente<br>Si possono implementare Semafori Binari con Semafori? S&#236;<br>Si possono implementare Semafori con Semafori Binari? S&#236;<br>hanno lo stesso potere espressivo<br><br>passaggio del testimone<br><br>metodo stato + testimone<br>modifica<br><ul class="indent"><li>mutex.P()</li><li>if (condizione per modifica falsa) mutex.V(); semaforo_modifica.P()</li><li>modifica</li><li>if (condizione per modifica1 vera) semaforo modifica 1.V()</li><li>else (condizione per modifica2 vera) semaforo modifica 2.V()</li><li>else (condizione per modifica3 vera) semaforo modifica 3V()</li><li>else mutex.V()</li></ul>RW con semafori e passaggio del testimone<br><br>Monitor definizione -- variabili condition<br>monitor banca {<br>&nbsp;&nbsp;&nbsp; int saldo = 0;<br>&nbsp;&nbsp;&nbsp; entry accredito_addebito(x):&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; saldo += x<br>&nbsp;&nbsp;&nbsp; entry getsaldo():<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return saldo<br>&nbsp;&nbsp;&nbsp; }<br><br>==========================================================================<br><br>Implementazione dei semafori con monitor:<br>&nbsp;&nbsp;&nbsp; monitor semaphore:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int value<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; condition oktoV<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int waiting<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; semaphore(x):&nbsp; value = x<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; entry P():<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if value == 0: waiting++; oktoV.wait(); waiting--<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value --<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; entry V():<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value++<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if waiting &gt; 0: oktoV.signal()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>wait e signal sono diverse dalle P e V dei semafori, assimilarle &#232; un errore<br>&#x27;wait&#x27; &#232; bloccante, quando un processo fa wait viene messo nella coda delle variabili condizione, quindi se il primo che ha fatto la wait su quella condizione entra nella coda e attende<br>&#x27;signal&#x27; sblocca una condizione, il primo rocesso che era in attesa di quella condizione entra nel monitor, e quello che ha fatto la signal va nello urgentStack<br>quando il processo che ora &#232; nel monitor perch&#233; &#232; stato riattivato esce dal monitor o va in wait, prima di poter ammettere altri processi dalla coda di input, viene preso un processo dalla urgentStack (in modo lifo)<br>se una signal sblocca una condizione che nessuno sta aspettando, quella condizione viene persa<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>Semaphore vs condition:<br>&nbsp;&nbsp;&nbsp; wait sempre blocccante - P solo se val == 0<br>&nbsp;&nbsp;&nbsp; signal viene persa se nessuno aspetta - V **ricorda**<br>&nbsp;&nbsp;&nbsp; signal (urgent) il&nbsp; processo riattivato parte prima che altre variazioni possano avere luogo nelle var del monitor<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>Problemi campione: PC BB DP RW<br>process producer:<br>&nbsp;&nbsp;&nbsp; while true:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = produce()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pc.add(x)<br>process consumer:<br>&nbsp;&nbsp;&nbsp; while true:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = pc.get()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; consume (y)<br><br>monitor pc:<br>&nbsp;&nbsp;&nbsp; T buffer<br>&nbsp;&nbsp;&nbsp; int full = 0<br>&nbsp;&nbsp;&nbsp; condititon ok2read &#x2F;&#x2F; full == 1<br>&nbsp;&nbsp;&nbsp; condititon ok2write &#x2F;&#x2F; full == 0<br>&nbsp;&nbsp;&nbsp; entry add(T x)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if full != 0 ok2write.wait()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer = x: full = 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ok2read.signal()<br>&nbsp;&nbsp;&nbsp; entry get():<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if full != 1 ok2read.wait()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z = buffer; full = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ok2write.signal()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return z<br>ATT.ne: QUESTO CHE SEGUE E&#x27; ERRATO! -&gt; possibile sovrascrittura (**)<br>&nbsp;&nbsp;&nbsp; entry get():<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if full != 1 ok2read.wait()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; full = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ok2write.signal()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return buffer<br><br>se non possiamo scrivere, aspettiamo di poter scrivere, quando siamo sicuri che full==0<br>una volta fatta signal si attivi il processo che aspettava la condizione, ci garantisce che in quel punto la condizione che dovevamo avere &#232; verificata, quindi possiamo sovrascrivere il valore del buffer erpch&#232; &#232; gi&#224; stato consumato, e dichiarare che l&#x27;elemento del buffer ora &#232; occupato<br>viceversa per leggere occorre che il buffer sia pieno, cio&#232; che ci sia un elemento scritto non ancora letto<br>quindi possiamo leggere le dichiarare l&#x27;elemento consumato perch&#232; possa essere sovrascritto<br><br>-&gt; (**) L&#x27;errore sta nel fatto che:<br>&nbsp;&nbsp;&nbsp; se non viene svuotato il buffer ok2write.signal() abilita qualcuno, e quindi che la get() restituisca il buffer che &#232; stato inserito per effetto della signal e non quello che doveva leggere<br>&nbsp;&nbsp;&nbsp; attenzione perch&#232; le signal possono attivare processi e modificare le condizioni<br>&nbsp;&nbsp;&nbsp; <u>la modifica dello stato deve essere fatta nel punto del codice in qui si modifica lo stato</u><br><br>#define BUFSIZE<br>monitor bb:<br>&nbsp;&nbsp;&nbsp; queue of T q<br>&nbsp;&nbsp;&nbsp; condititon ok2read &#x2F;&#x2F; q.lenght() &gt; 0<br>&nbsp;&nbsp;&nbsp; condititon ok2write &#x2F;&#x2F; q.lenght() &lt; BUFSIZE<br>&nbsp;&nbsp;&nbsp; entry add(T x)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if q.lenght() &gt;= BUFSIZE ok2write.wait()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q.enqueue(x)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ok2read.signal()<br>&nbsp;&nbsp;&nbsp; entry get():<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if q.lenght() == 0 ok2read.wait()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z = q.dequeue()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ok2write.signal()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return z<br><br>process philo(i) i = 0,..,4:<br>&nbsp;&nbsp;&nbsp; think<br>&nbsp;&nbsp;&nbsp; dp.starteat(i)<br>&nbsp;&nbsp;&nbsp; eat<br>&nbsp;&nbsp;&nbsp; dp.endeat(i)<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>monitor dp:<br>&nbsp;&nbsp;&nbsp; bool chopstick[5] &#x2F;&#x2F; true = in_use<br>&nbsp;&nbsp;&nbsp; condition ok2get[5] &#x2F;&#x2F; chopstick[i] == 0<br>&nbsp;&nbsp;&nbsp; entry starteat(i) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (chopstick[i] == true) ok2get[i].wait()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chopstick[i] = true &#x2F;&#x2F;(**)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (chopstick[(i+1) % 5] == true) ok2get[(i+1) % 5].wait()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chopstick[(i+1) % 5] = true<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; entry endeat(i) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chopstick[i] = false; ok2get[i].signal()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chopstick[(i+1) % 5] = false; ok2get[(i+1) % 5].signal()<br>&nbsp;&nbsp;&nbsp; }<br><br>c&#x27;&#232; deadlock? vediamo nel caso che tutti prendano la bacchetta a sinistra<br>chopstick[i] == 0<br><br>0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prendo 0, 1 &#232; occupato<br>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prende 1, 2 &#232; occuapto&nbsp;&nbsp;&nbsp;<br>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prende 2, 3 &#232; occupato<br>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prende 3, 4 &#232; occupato<br>4.&nbsp;&nbsp;&nbsp;&nbsp; prende 4, 0 &#232; occupato<br><br><strong>siamo con i monitor, quindi abbiamo un vantaggio, nel fare &#x27;4.&nbsp;&nbsp; prende 4, 0 &#232; occupato&#x27; il monitor ha la mutua esclusione, qundi se prende 4 in questa situazione non pu&#242; trovare 0 occupato perch&#232; 0 se 4 &#232; libera, 0 (che in questa ipotesi viene preso dopo) potr&#224; essere preso solo pi&#249; tardi, se trova 0 libero l&#x27;ultimo non pu&#242; trovarlo occupato perch&#232; l&#x27;unico altro che poteva prendere 0, nel tempo che prende sia 4 che 0 non rilascia la mutua esclusione (Si prof chiarissimo)</strong><br>con i monitor questa soluzione non da deadlock, rispetto ai semafori nel punto (**) non si pu&#242; passare all&#x27;altro processo, perch&#232; se &#232; libero prova direttamente a prendere l&#x27;altra bacchetta&nbsp;&nbsp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<br>monitor dp:<br>&nbsp;&nbsp;&nbsp; bool eating[5]<br>&nbsp;&nbsp;&nbsp; condition ok2eat[5] &#x2F;&#x2F; eating[(i - 1) %5] == false &amp;&amp; eating[(i + 1) %5] ==false<br>&nbsp;&nbsp;&nbsp; entry starteat(i) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if eating[(i - 1) %5] == true || eating[(i + 1) %5] == true: ok2eat[i].wait()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eating[i] = true<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; entry endeat(i) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eating[i] = false<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (eating[(i-2) % 5] == false) ok2eat[(i - 1) %5] .signal()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (eating[(i+2) % 5] == false) ok2eat[(i + 1) %5] .signal()<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; (i-1) % 5 -&gt; (i + 4) % 5&nbsp; -------- (i-2) %5 -&gt; (i +3) % 5<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>reader: rw.startread(); READ; rw.endread()<br>wwriter: rw.startwrite(); WRITE; rw.endwrite()<br><br>monitor rw:<br>&nbsp;&nbsp;&nbsp; int nr, nw, ww<br>&nbsp;&nbsp;&nbsp; condition ok2read &#x2F;&#x2F; nw == 0<br>&nbsp;&nbsp;&nbsp; condition ok2write &#x2F;&#x2F; nr == 0 &amp;&amp; nw == 0<br>&nbsp;&nbsp;&nbsp; entry startread():<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (nw &gt; 0 || ww &gt; 0) ok2read.wait()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nr++<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ok2read.signal()<br>&nbsp;&nbsp;&nbsp; entry endread():<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nr--<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if nr == 0 ok2write.signal()<br>&nbsp;&nbsp;&nbsp; entry startwrite():<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (nr &gt; 0 || nw &gt; 0) ww++; ok2write.wait(); ww--<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nw++<br>&nbsp;&nbsp;&nbsp; entry endwrite():<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nw--<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ok2read.signal()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (nr == 0) ok2write.signal()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>se c&#x27;&#232; unoscrittore aspetto perch&#232; la condizione per poter leggere &#232; falsa<br>se finisco la lettura e il numero di lettori &#232; &gt; 0 non posso mandare avanti nessuno scrittore<br>se il numero di lettori &#232; = 0 posso mandare avanti scrittori, posso in ogni caso mandare avanti lettori ma &#232; inutile<br>si pu&#242; scrivere solo se non ci sono lettori e non ci sono scrittori, a questo punto si pu&#242; scrivere e il numero degli scrittori diventa uno, ma per poter scrivere occorre che non ci sia neanche uno scrittore che abbia gi&#224; fatto ok2write()<br><br>Implementazione monitor con semafori<br><br>Esperimenti coi semafori e monitor in C<br>class monitor:<br>&nbsp;&nbsp;&nbsp; semaphore mutex(1)<br>&nbsp;&nbsp;&nbsp; stack of semaphore urgent<br>&nbsp;&nbsp;&nbsp; public enter: mutex.P()<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; def exiting():&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!urgent.empty): urgent.pop().V()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else: mutex.V()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; public exit: exiting()<br><br>&nbsp;&nbsp;&nbsp; class condition:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; queue of semaphore wqueue<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public wait:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new sem ws(0); wqueue.enqueue(ws);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exiting()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ws.P()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free(ws)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public signal()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!wqueue.empty()):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ss = wqueue.dequeue()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new sem ws(0); urgent.push(ws)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ss.V()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ws.P()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free(ws)<br><br># LEZIONE DEL 27&#x2F;11&#x2F;2020 ----------------------------------------------------------------------------------------------------<br>## Progetto<br>### Presentazione<br>## Strumenti per la programmazione<br>### Make<br>### CMake<br>### Autotools di GNU<br><br># LEZIONE DEL 02&#x2F;12&#x2F;2020 ----------------------------------------------------------------------------------------------------<br><br>Il modello che utilizziamo non prevede multicast&#x2F;broadcast, e i messaggi sono affidabili: non vengono mai persi.<br><br>Il parametro della reiceve pu&#242; esssere ANY di conseguenza accetterebbe messaggi da chiunque, il che potrebbe creare problemi nel momento in cui noi vogliam sapere chi sia il mittente.&nbsp;<br>Questo lo risolviamo quando implementiamo la sincrona partendo dalla asincrona poich&#232; dobbiamo mandare un ACK di risposta al mittente quindi modifichiamo il codice in modo da salvarci il mittente, se non ce lo salvassimo con &quot;realsender&quot; non sapremmo a chi rispondere dato che in inpu ci arriverebbe solo &quot;ANY&quot;<br><br>Pizzino della lezione di Sistemi Operativi 02 dicembre 2020...<br><br>monitor &lt;-&gt; semafori &lt;-&gt; sem binari hanno lo stesso potere espressivo.<br><br>Visione teorica della programmazione concorrente:&nbsp; (DJIksta Hoare ....)<br>&nbsp;&nbsp;&nbsp; si parla di PROCESSI, sempre. non esiste la parola thread.<br>&nbsp;&nbsp;&nbsp; modello a mem privata oo a mem condivisa<br><br>VIsione implementativa (Torvarld, Stallman, ....)<br>A livello programmi utente si parla di processi = entita&#x27; depositarie delle risorse per l&#x27;esecuzione.<br>Thread sono i &quot;fili&quot; esecutivi.<br><br>IMPL: 1 processo con + thread --&gt; teorico mem condivisa<br>IMPL: + proc, ogni proc 1 thread -&gt; teorico mem privata<br>IMPL: codice del kernel -&gt; mem condivisa<br><br>Modello a memoria condivisa. e.g. sem+monitor<br>concetto chiave = sincronizzazione.... comunicazione = condivisione + sincro<br><br>Modello a mem privata:&nbsp; message passing<br>concetto chiave = comunicazione...&nbsp; sincronizzazione implementata con comunicazione<br><br>MESSAGE PASSING SINCRONO:<br>&nbsp;&nbsp;&nbsp; ssend(msg, dest)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ** BLOCCANTE<br>&nbsp;&nbsp;&nbsp; srecv(sender) -&gt; msg&nbsp; ** BLOCCANTE<br>MESSAGE PASSING ASINCRONO:<br>&nbsp;&nbsp;&nbsp; asend(msg, dest)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ** NON BLOCCANTE<br>&nbsp;&nbsp;&nbsp; arecv(sender) -&gt; msg ** BLOCCANTE<br>MESSAGE PASSING COMPLETAMENTE ASINCRONO (non blocking)<br>&nbsp;&nbsp;&nbsp; nbsend(msg, dest)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ** NON BLOCCANTE<br>&nbsp;&nbsp;&nbsp; nbrecv(sender) -&gt; msg ** NON BLOCCANTE<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>Alice:&nbsp; ??send(&quot;ciao, bob&quot;, Bob)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bob ??recv(Alice)<br>sync : aspettano entrambi *** No buffer<br>async: aspetta solo Bob (se Alice non ha ancora inviato) *** occorre buffer<br>non blocking: nessuno aspetta *** occorre buffer<br><br>quando si chiama una recv, il valore del paramentro puo&#x27; essere ANY. in questo caso&nbsp; viene ricevuto il primo omsg da qualsiasi mittente.<br>Alice:&nbsp; ??send(&quot;ciao, bob&quot;, Bob)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bob ??recv(ANY)<br><br>msg affidabili: non vengono&nbsp; mai perduti<br>FIFO<br><br>abbiamo MP asincrono, vogliamo implementare quello sincrono:<br>def ssend(msg, dest):<br>&nbsp;&nbsp;&nbsp; asend((myself(), msg), dest)<br>&nbsp;&nbsp;&nbsp; arecv(dest)<br>def srecv(sender):<br>&nbsp;&nbsp;&nbsp; (realsender, msg) = arecv(sender)<br>&nbsp;&nbsp;&nbsp; asend(ACKNOWLEDGE, realsender)<br>&nbsp;&nbsp;&nbsp; return msg<br><br>abbiamo MP sincrono vogliamo implementare quello asincrono:<br>&#x2F;* i msg sono della forma (messaggio, mittente, destinazione)<br>def asend(msg, dest)<br><ul class="indent"><li>ssend((msg, myself(), dest), server)</ul><br>def arecv(sender):<br>&nbsp;&nbsp;&nbsp; ssend((NULL, sender, myself()) server)<br>&nbsp;&nbsp;&nbsp; return srecv(server)<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>process server:<br>&nbsp;&nbsp;&nbsp; boolean waiting[]&nbsp;&nbsp;&nbsp; &#x2F;&#x2F;&#x2F; waiting[id] = NULL, se non in attesa, oppure id del sender opppure ANY<br>&nbsp;&nbsp;&nbsp; msg db ---- metodi: db.add(msg, mittente, destinazione)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db.get(mittente destinazione) -&gt; NULL se non c&#x27;e&#x27;, msg alrimenti<br>&nbsp;&nbsp;&nbsp; while True:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (msg, s, d) = srecv(ANY)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if msg == NULL:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#x2F;&#x2F; dal destinatario<br><ul class="indent"><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (((msg = db.get(s, d)) == NULL)</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; waiting[d] = s</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ssend(msg, d)</ul>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#x2F;&#x2F; dal mittente<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (waiting[d] == s || waiting[d] == ANY)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ssend(msg, d)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; waiting[d] = NULL<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db.add(msg, s, d)<br><br>abbiamo MP asincrono, vogliamo implementare quello completamente asincrono<br>def nbsend(msg, dest):<br>&nbsp;&nbsp;&nbsp; asend((myself(), msg), dest)<br>def nbrecv(sender)<br>&nbsp;&nbsp;&nbsp;&nbsp; static local db.<br>&nbsp;&nbsp;&nbsp; asend((myself(), TAG), myself())<br>&nbsp;&nbsp;&nbsp; while True:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (msgsnd, msg) = arecv(ANY)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if msgsnd == myself() &amp;&amp; msg == TAG: break<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db,add(msgsnd, msg)<br>&nbsp;&nbsp;&nbsp; return db.get(sender) &#x2F;&#x2F;Spostato fuori dal loop da Samuele Marro e Luca Donno altrimenti non ha senso<br><br>abbiamo MP completamente asincrono, vogliamo implementare quello asincrono<br>def asend(msg, dest):<br>&nbsp;&nbsp;&nbsp; nbsend(msg, dest)<br>def arecv(sender):<br>&nbsp;&nbsp;&nbsp; while&nbsp; ((msg = nbrecv(sender)) == NULL)<br><ul class="indent"><li>&nbsp;&nbsp;&nbsp; ;</li><li>return msg</ul><br>complt asincrono&nbsp; &lt; asincrono&nbsp;&nbsp;&nbsp; &#x2F;&#x2F;&#x2F; busy wait<br>sincrono &lt; asincrono&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#x2F;&#x2F;&#x2F; proc server<br><br><br>prog. concorrente: modello a memoria condivisa vs. modello a memoria privata<br>message passing definizione<br>MP asincrono, sincrono completamente asincrono<br><br>trasformazioni...<br><br>Conclusioni modelli e poteri espressivi<br><br># LEZIONE DEL 04&#x2F;12&#x2F;2020 ----------------------------------------------------------------------------------------------------<br>## Progetto<br>### Fase 1<br>## Strumenti per la programmazione<br>### Git<br>### Github<br><br># LEZIONE DEL 09&#x2F;12&#x2F;2020 ----------------------------------------------------------------------------------------------------<br>## Programmazione Concorrente<br>### Message Passing<br>#### Problemi Classici col message passing<br>PC - MP sincrono:<br>```<br>process producer::<br><ul class="indent"><li>while True:<ul class="indent"><li>x = produce()</li><li>ssend(msg, buffer)</ul></li></ul><br>process buffer:<br>&nbsp;&nbsp;&nbsp; while True:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg = srecv(producer)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ssend(msg consumer)<br><br>process consumer:<br><ul class="indent"><li>while True:<ul class="indent"><li>x = srecv(buffer)</li><li>consume(x)</ul></li></ul>```<br>PC - MP asincrono:<br>```<br>process producer::<br><ul class="indent"><li>count = 0</li><li>while True:<ul class="indent"><li>x = produce()</li><li>asend(x, consumer)</li><li>if count &gt;= 1: arecv(consumer) # <strong>non viene decrementato count?</strong></li><li>count++</ul></li></ul><br>process consumer:<br><ul class="indent"><li>while True:<ul class="indent"><li>x = arecv(producer)</li><li>asend(ACNOWLEDGE, producer)</li><li>consume(x)</ul></li></ul>```<br>PC - MS asincrono con buffer:<br>```<br>process producer::<br><ul class="indent"><li>count = 0</li><li>while True:<ul class="indent"><li>x = produce()</li><li>asend(x, consumer)</li><li>if count &gt;= BUFSIZE: arecv(consumer)</li><li>count++</ul></li></ul><br>process consumer:<br><ul class="indent"><li>while True:<ul class="indent"><li>x = arecv(producer)</li><li>asend(ACNOWLEDGE, producer)</li><li>consume(x)</ul></li></ul>```<br>DP - MP asincrono:<br>```<br>process philo[i]: i=0,...,4<br><ul class="indent"><li>while True:<ul class="indent"><li>think</li><li>asend((req, i), chopstick[i])</li><li>arecv(chopstick[i])</li><li>asend((req, i), chopstick[(i+1) %5])</li><li>arecv(chopstick[(i+1) %5])</li><li>eat</li><li>asend((release, i), chopstick[i])</li><li>asend((release, i), chopstick[(i+1) %5])</li></ul></li></ul>process chopstick[i], i = 0... 4:<br>&nbsp;&nbsp;&nbsp; while True:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (tag, index) = arecv(ANY)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; asend(acknowledge, philo[index])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arecv(philo[index]);<br>```<br>## Python<br><br># LEZIONE DEL 11&#x2F;12&#x2F;2020 -----------------------------------------------------------------------------------------------------<br>## Python<br><br>FINE --------------------------------------------------------------------------------------------------------------------------------<br>PER LE LEZIONI DEL SECONDO SEMESTRE: <a href="https&#x3a;&#x2F;&#x2F;etherpad&#x2e;wikimedia&#x2e;org&#x2F;p&#x2F;OoPeXXX4XJSIPCAN2jDo" rel="noreferrer noopener"><strong>https:&#x2F;&#x2F;etherpad.wikimedia.org&#x2F;p&#x2F;OoPeXXX4XJSIPCAN2jDo</strong></a><br><br>==================================================================<br>&quot;Se colleghiamo un utente ad una macchina prende la scossa e si fulmina&quot;&nbsp;<br><br>I gruppi per il progetto del corso sono stati creati.<br><br>Una volta collegati remotamente ad una macchina del sistema distribuito dipartimentale<br>(usando ssh), potete verificare di appartenere al gruppo corretto in due modi;<br><br>* il comando &quot;groups | tr &#x27; &#x27; &#x27;\n&#x27; | grep lso21az&quot; deve restituire il codice del vostro gruppo<br><br>* il comando &quot;getent group | grep lso21azXX&quot; (sostituendo a XX il numero del vostro gruppo)<br>deve fornire l&#x27;elenco dei componenti del gruppo.<br><br>Il pathname delle directory di lavoro (NB: non sono le directory di consegna) &#232;:<br>&#x2F;home&#x2F;students&#x2F;LABSO&#x2F;2021&#x2F;lso21az* &lt;- al posto di * numero gruppo<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
</body>
</html>
